<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>限流策略及实现方案</title>
      <link href="/2024/02/17/study-12/"/>
      <url>/2024/02/17/study-12/</url>
      
        <content type="html"><![CDATA[<p>如果我们的系统有调用别人的收费接口，那就需要考虑到接口有被恶意刷量的风险，如果不加以防护，会产生大量的费用。这个时候可以做一些限制，比如限制用户的总调用次数，或者限制用户单位时间内的调用次数，也就是限流。</p><p>限流的场景并不只有上面的一种，当用户某一时间的请求数过多，可能超过服务器的承受阈值时就需要考虑限流。比如电商网站在双十一或者618做的一些秒杀活动，参与人数众多，不可能在同一时间让所有用户请求都到达服务器，就需要限流，否则会导致服务器宕机。</p><h2 id="限流："><a href="#限流：" class="headerlink" title="限流："></a>限流：</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><p>限流：在计算机网络中，限流就是控制网络接口发送或接收请求的速率，它可防止DoS攻击和限制Web爬虫。也称流量控制。是指系统在面临高并发，或者大流量请求的情况下，限制新的请求对系统的访问，从而保证系统的稳定性。</p><h3 id="限流的阈值选择："><a href="#限流的阈值选择：" class="headerlink" title="限流的阈值选择："></a>限流的阈值选择：</h3><p>需要参考正常用户的访问频率，比如每秒每个用户只能访问一次。针对秒杀场景的限流则需要考虑服务器的承受阈值，本文不重点考虑这种情况。</p><h3 id="限流的分类："><a href="#限流的分类：" class="headerlink" title="限流的分类："></a>限流的分类：</h3><p>按限流的粒度分类：</p><ul><li>单机限流：指请求进入到某一个服务节点后超过了限流阈值，服务节点采取了一种限流保护措施。</li><li>分布式限流：狭义的说法是在接入层实现多节点合并限流，比如NGINX+redis，分布式网关等，广义的分布式限流是多个节点（可以为不同服务节点）有机整合，形成整体的限流服务。</li></ul><p>按限流策略分类（本文重点！！！）：</p><ul><li>固定窗口限流： 将一段时间内的流量限制为固定的数量或速率，例如每秒最多处理100个请求。</li><li>滑动窗口限流： 在一个滑动的时间窗口内，动态地调整限流速率，例如根据系统负载自适应地调整限流速率。</li><li>漏桶算法： 数据以固定的速率被放入一个固定容量的”漏桶”中，超出容量的部分将被丢弃或延迟处理。</li><li>令牌桶算法： 限制数据传输速率，允许突发流量，但在每个时间段内的平均速率是固定的。</li></ul><p>按照对象类型分类：</p><ul><li>基于请求限流：根据请求的数量或频率来限制访问的策略。</li><li>基于资源限流： 根据系统资源的使用情况来限制访问的策略。</li></ul><h2 id="四种限流策略（算法）："><a href="#四种限流策略（算法）：" class="headerlink" title="四种限流策略（算法）："></a>四种限流策略（算法）：</h2><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/376564740">面试必备：4种经典限流算法讲解 - 知乎 (zhihu.com)</a></p><h3 id="1-固定窗口算法："><a href="#1-固定窗口算法：" class="headerlink" title="1. 固定窗口算法："></a><strong>1. 固定窗口算法</strong>：</h3><p>单位时间允许固定的用户请求，比如 每分钟只允许10次请求。</p><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><ol><li><strong>时间窗口划分：</strong> 将时间划分为固定大小的窗口，例如将一分钟划分为 60 个 1 秒的窗口。</li><li><strong>计数器初始化：</strong> 每个窗口对应一个计数器，初始值为 0。</li><li><strong>请求处理：</strong> 每当有请求到来时，根据请求的时间戳确定该请求属于哪个时间窗口，然后将对应的计数器加一。</li><li><strong>限流判断：</strong> 在每个时间窗口结束时，检查对应的计数器值是否超过了限流阈值，如果超过了则拒绝后续的请求。</li></ol><h4 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li><strong>初始化计数器数组：</strong> 创建一个大小为窗口数量的计数器数组，用于存储每个时间窗口内的请求数量。</li><li><strong>请求到来时更新计数器：</strong> 每当有请求到来时，根据请求的时间戳确定所属的时间窗口，然后将对应窗口的计数器加一。</li><li><strong>定时重置计数器：</strong> 定时器在每个时间窗口结束时触发，将对应窗口的计数器清零，准备开始下一个时间窗口的计数。</li><li><strong>限流判断：</strong> 每当有请求到来时，都检查对应时间窗口的计数器值是否超过了限流阈值，如果超过了则拒绝请求。</li></ol><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul><li>实现简单，容易理解。</li><li>精度高，能够比较准确地控制请求的通过速率。</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><p><strong>存在流量突刺的问题：</strong>例如在一个时间窗口的开始时瞬间发生大量请求，可能导致该时间窗口内的请求量超过限流阈值。</p><p>比如：每分钟只允许10个用户访问，即单位时间为60s，阈值为10。</p><p>在0 - 59s里没有用户访问，在第59里突然来了10个请求，没超过限制，</p><p>60s结束，计数器刷新，在0 - 1s中又来了10个用户请求，也没超过限制，</p><p>但是在上轮的第59s 到本轮的1s 这2s内就有20个访问请求了，已经超过了服务器的承受阈值，可能导致服务器宕机。</p></li><li><p><strong>计数器的粒度不够细致，可能导致请求的不均匀分布。</strong></p></li></ul><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 固定窗口时间算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">fixedWindowsTryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">//获取系统当前时间</span></span><br><span class="line">    <span class="keyword">if</span> (currentTime - lastRequestTime &gt; windowUnit) &#123;  <span class="comment">//检查是否在时间窗口内</span></span><br><span class="line">        counter = <span class="number">0</span>;  <span class="comment">// 计数器清0</span></span><br><span class="line">        lastRequestTime = currentTime;  <span class="comment">//开启新的时间窗口</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (counter &lt; threshold) &#123;  <span class="comment">// 小于阀值</span></span><br><span class="line">        counter++;  <span class="comment">//计数器加1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-滑动窗口算法："><a href="#2-滑动窗口算法：" class="headerlink" title="2. 滑动窗口算法："></a><strong>2. 滑动窗口算法</strong>：</h3><p>还是单位时间允许固定的用户请求，但是这个单位时间是滚动的：</p><p>比如每2min 允许10次请求，每1分钟窗口滑动一次，即单位时间为2min，阈值为10，滑动时间为1min.</p><p> 10:00 开始，10:00 - 10:02算一个单位时间，10:01 - 10:03又算一个单位时间。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240217163132411.png" alt="image-20240217163132411"></p><p>一定程度上解决了固定窗口算法流量突刺的问题，但是没有完全解决，和滑动时间有关。</p><h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><ol><li><strong>时间窗口划分：</strong> 将整个时间窗口划分为多个小的时间片段（例如1秒），每个时间片段内维护一个计数器。</li><li><strong>请求处理：</strong> 每当有请求到来时，根据请求的时间戳确定该请求属于哪个时间片段，并将对应的计数器加一。</li><li><strong>计数器滑动：</strong> 定时器定期触发，将计数器数组向前滑动一个时间片段，同时清零最后一个时间片段的计数器。</li><li><strong>限流判断：</strong> 每当有请求到来时，都检查对应时间片段的计数器值是否超过了限流阈值，如果超过了则拒绝请求。</li></ol><h4 id="实现步骤：-1"><a href="#实现步骤：-1" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li><strong>初始化计数器数组：</strong> 创建一个大小为时间窗口内时间片段数的计数器数组，用于存储每个时间片段内的请求数量。</li><li><strong>请求到来时更新计数器：</strong> 每当有请求到来时，根据请求的时间戳确定所属的时间片段，然后将对应时间片段的计数器加一。</li><li><strong>定时滑动计数器：</strong> 定时器在每个时间片段结束时触发，将计数器数组向前滑动一个时间片段，同时清零最后一个时间片段的计数器。</li><li><strong>限流判断：</strong> 每当有请求到来时，都检查对应时间片段的计数器值是否超过了限流阈值，如果超过了则拒绝请求。</li></ol><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a><strong>优点：</strong></h4><ul><li>更平滑地控制请求通过速率，减少了固定窗口算法中可能出现的突发请求问题。</li><li>精度较高，对于请求的限流更为细致。</li></ul><h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>实现相对复杂，需要维护计数器数组的滑动。</li><li>并没有完全解决流量突刺问题，滑动时间越小，效果越好，但是往往很难找到合适的滑动时间。</li></ul><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 单位时间划分的小周期（单位时间是1分钟，10s一个小格子窗口，一共6个格子）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">SUB_CYCLE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 每分钟限流请求数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="variable">thresholdPerMin</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 计数器, k-为当前窗口的开始时间值秒，value为当前窗口的计数</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, Integer&gt; counters = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 滑动窗口时间算法实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">slidingWindowsTryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">long</span> <span class="variable">currentWindowTime</span> <span class="operator">=</span> LocalDateTime.now().toEpochSecond(ZoneOffset.UTC) / SUB_CYCLE * SUB_CYCLE; <span class="comment">//获取当前时间在哪个小周期窗口</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">currentWindowNum</span> <span class="operator">=</span> countCurrentWindow(currentWindowTime); <span class="comment">//当前窗口总请求数</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//超过阀值限流</span></span><br><span class="line">       <span class="keyword">if</span> (currentWindowNum &gt;= thresholdPerMin) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//计数器+1</span></span><br><span class="line">       counters.get(currentWindowTime)++;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 统计当前窗口的请求数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countCurrentWindow</span><span class="params">(<span class="type">long</span> currentWindowTime)</span> &#123;</span><br><span class="line">       <span class="comment">//计算窗口开始位置</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> currentWindowTime - SUB_CYCLE* (60s/SUB_CYCLE-<span class="number">1</span>);</span><br><span class="line">       <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//遍历存储的计数器</span></span><br><span class="line">       Iterator&lt;Map.Entry&lt;Long, Integer&gt;&gt; iterator = counters.entrySet().iterator();</span><br><span class="line">       <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">           Map.Entry&lt;Long, Integer&gt; entry = iterator.next();</span><br><span class="line">           <span class="comment">// 删除无效过期的子窗口计数器</span></span><br><span class="line">           <span class="keyword">if</span> (entry.getKey() &lt; startTime) &#123;</span><br><span class="line">               iterator.remove();</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//累加当前窗口的所有计数器之和</span></span><br><span class="line">               count =count + entry.getValue();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-漏桶算法："><a href="#3-漏桶算法：" class="headerlink" title="3. 漏桶算法："></a><strong>3. 漏桶算法</strong>：</h3><p>以<strong>固定的速率</strong>处理请求，当请求桶满后，拒绝请求。</p><p>模拟了一个水桶，水（请求）以固定的速率漏出（处理请求），但如果桶已满，则溢出的水会被丢弃。</p><p>比如，1s内处理10个请求，桶的容量为10，每0.1s固定处理1个请求。</p><p>如果1s内来了10个请求，都可以处理完。</p><p>如果1s内来了11个请求，第11个请求溢出，被拒绝。</p><h4 id="原理：-2"><a href="#原理：-2" class="headerlink" title="原理："></a>原理：</h4><ol><li><strong>桶容量限制：</strong> 漏桶有一个固定的容量，表示系统可以处理的最大请求数量。当桶已满时，多余的请求将被丢弃。</li><li><strong>固定流出速率：</strong> 漏桶以固定的速率处理请求，即使瞬时的请求数量超过了系统的处理能力，也只会以固定的速率进行处理。</li><li><strong>请求处理：</strong> 每当有请求到来时，都会向漏桶中加入一个请求。如果漏桶未满，则请求立即被处理；如果漏桶已满，则请求被丢弃。</li><li><strong>流出控制：</strong> 漏桶以固定的速率处理请求，无论实际请求数量多少，都会以固定速率向外输出请求。这种方式可以平滑网络流量，防止突发流量对系统造成冲击。</li></ol><h4 id="实现步骤：-2"><a href="#实现步骤：-2" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li><strong>初始化漏桶参数：</strong> 包括桶的容量和固定的流出速率。</li><li><strong>请求处理：</strong> 每当有请求到来时，检查漏桶是否已满，如果未满，则向漏桶中加入一个请求；如果已满，则拒绝请求。</li><li><strong>流出控制：</strong> 使用定时器定期从漏桶中流出一个请求，以固定的速率进行处理。</li></ol><h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h4><ul><li>简单有效，易于实现。</li><li>能一定程度上避免流量突刺。</li><li>能够平滑控制请求的处理速率，避免系统因突发请求而崩溃。</li></ul><h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h4><ul><li>对于突发流量处理能力有限，可能造成一些请求的延迟或丢失。</li><li>如果流量持续超出桶的容量，可能导致请求被频繁丢弃，影响用户体验。</li></ul><h4 id="代码实现：-1"><a href="#代码实现：-1" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 每秒处理数（出水率）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">long</span> rate;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  当前剩余水量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">long</span> currentWater;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 最后刷新时间</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">long</span> refreshTime;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 桶容量</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">long</span> capacity;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 漏桶算法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">leakybucketLimitTryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">//获取系统当前时间</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">outWater</span> <span class="operator">=</span> (currentTime - refreshTime) / <span class="number">1000</span> * rate; <span class="comment">//流出的水量 =(当前时间-上次刷新时间)* 出水率</span></span><br><span class="line">       <span class="type">long</span> <span class="variable">currentWater</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, currentWater - outWater); <span class="comment">// 当前水量 = 之前的桶内水量-流出的水量</span></span><br><span class="line">       refreshTime = currentTime; <span class="comment">// 刷新时间</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 当前剩余水量还是小于桶的容量，则请求放行</span></span><br><span class="line">       <span class="keyword">if</span> (currentWater &lt; capacity) &#123;</span><br><span class="line">           currentWater++;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">// 当前剩余水量大于等于桶的容量，限流</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="4-令牌桶算法："><a href="#4-令牌桶算法：" class="headerlink" title="4. 令牌桶算法："></a><strong>4. 令牌桶算法</strong>：</h3><p>有一个令牌管理员，根据限流大小，定速往令牌桶里放令牌。当桶里的令牌满了，就丢弃令牌。</p><p>每个请求拿一个令牌，只要能拿到令牌就可以执行请求，执行请求时将该令牌销毁；</p><p>如果有多个请求同时拿到令牌，就可以并发执行这些请求，并销毁他们的令牌；</p><p>如果请求拿不到令牌，就被拒绝。</p><h4 id="原理：-3"><a href="#原理：-3" class="headerlink" title="原理："></a>原理：</h4><ol><li><strong>令牌桶：</strong> 令牌桶中存放着一定数量的令牌，这些令牌以固定的速率被添加到桶中。</li><li><strong>请求处理：</strong> 当请求到达时，如果桶中有足够的令牌，则可以被处理；否则，请求被暂时缓存或直接丢弃。</li><li><strong>令牌生成速率：</strong> 令牌以固定速率被添加到令牌桶中，保持桶中令牌数量的稳定。</li><li><strong>请求消耗令牌：</strong> 每当有请求到达时，桶中的令牌数量会相应减少，表示该请求已经被处理。</li></ol><h4 id="实现步骤：-3"><a href="#实现步骤：-3" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li><strong>初始化令牌桶参数：</strong> 包括桶的容量和固定的生成速率。</li><li><strong>令牌生成：</strong> 使用定时器以固定速率向桶中添加令牌。</li><li><strong>请求处理：</strong> 每当有请求到来时，检查桶中是否有足够的令牌。如果有，则处理请求并消耗相应的令牌；如果没有，则根据策略处理请求（等待或丢弃）。</li></ol><h4 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a>优点：</h4><ul><li><p>可以并发的执行请求，提高效率。</p></li><li><p>能够平滑控制请求的处理速率，避免系统因突发请求而崩溃。</p></li></ul><h4 id="缺点：-3"><a href="#缺点：-3" class="headerlink" title="缺点："></a>缺点：</h4><ul><li><p>如果流量超过桶的容量，可能会导致一些请求被丢弃或延迟处理。</p><p>比如桶容量是10，每分钟生成并向桶中投放10个令牌，</p><p>可能在前10秒内桶里的令牌就被拿完了，</p><p>后面50秒内的请求就会被拒绝或者等到下一分钟重新生成令牌。</p></li><li><p>需要额外的定时器来定期生成令牌，增加了系统复杂性。</p></li></ul><h4 id="代码实现：-2"><a href="#代码实现：-2" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 每秒处理数（放入令牌数量）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> putTokenRate;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 最后刷新时间</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> refreshTime;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 令牌桶容量</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> capacity;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当前桶内令牌数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> <span class="variable">currentToken</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 漏桶算法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">tokenBucketTryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();  <span class="comment">//获取系统当前时间</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">generateToken</span> <span class="operator">=</span> (currentTime - refreshTime) / <span class="number">1000</span> * putTokenRate; <span class="comment">//生成的令牌 =(当前时间-上次刷新时间)* 放入令牌的速率</span></span><br><span class="line">      currentToken = Math.min(capacity, generateToken + currentToken); <span class="comment">// 当前令牌数量 = 之前的桶内令牌数量+放入的令牌数量</span></span><br><span class="line">      refreshTime = currentTime; <span class="comment">// 刷新时间</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//桶里面还有令牌，请求正常处理</span></span><br><span class="line">      <span class="keyword">if</span> (currentToken &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          currentToken--; <span class="comment">//令牌数量-1</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="限流的实现："><a href="#限流的实现：" class="headerlink" title="限流的实现："></a>限流的实现：</h2><h3 id="单机限流："><a href="#单机限流：" class="headerlink" title="单机限流："></a>单机限流：</h3><h4 id="1-Guava-RateLimiter-推荐"><a href="#1-Guava-RateLimiter-推荐" class="headerlink" title="1. Guava RateLimiter(推荐):"></a>1. Guava RateLimiter(推荐):</h4><p>参考文档：</p><p><a href="http://ifeve.com/guava-ratelimiter/">Guava官方文档-RateLimiter类 | 并发编程网 – ifeve.com</a></p><p><a href="https://zhuanlan.zhihu.com/p/205266820">谷歌Guava限流工具RateLimiter - 知乎 (zhihu.com)</a></p><p>Guava RateLimiter是Google Guava库中提供的一种工具，用于实现令牌桶算法进行限流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.RateLimiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个每秒最多处理10个请求的RateLimiter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rateLimiter.tryAcquire()) &#123;</span><br><span class="line">            <span class="comment">// 可以处理请求的逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Request processed successfully&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 请求被限流，处理限流逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Request rate limited&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RateLimiter.create(10.0)</code>创建了一个每秒最多处理10个请求的RateLimiter实例。<code>tryAcquire()</code>方法尝试获取一个许可，如果获取成功则返回<code>true</code>，表示可以处理请求；如果获取失败则返回<code>false</code>，表示请求被限流。</p><p>Guava RateLimiter还提供了其他方法，如<code>acquire()</code>用于获取许可，如果没有许可则会阻塞直到获取到许可为止；<code>tryAcquire(long timeout, TimeUnit unit)</code>用于在一定时间内尝试获取许可，如果超过指定时间仍未获取到许可则返回<code>false</code>。</p><h4 id="2-Bucket4j"><a href="#2-Bucket4j" class="headerlink" title="2. Bucket4j:"></a>2. Bucket4j:</h4><p>Bucket4j是一个用于实现令牌桶算法的Java库，同样使用了令牌桶算法进行限流。</p><p>官方仓库：<a href="https://github.com/bucket4j/bucket4j">bucket4j/bucket4j: Java rate limiting library based on token-bucket algorithm. (github.com)</a></p><p>官方文档：<a href="https://bucket4j.com/">Current version 8.8.0 documentation (bucket4j.com)</a></p><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/491073656">如何在 Java 中通过 Bucket4j 提供速率限制 - 知乎 (zhihu.com)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.github.bucket4j.Bandwidth;</span><br><span class="line"><span class="keyword">import</span> io.github.bucket4j.Bucket;</span><br><span class="line"><span class="keyword">import</span> io.github.bucket4j.ConsumptionProbe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.Duration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个每秒最多处理10个请求的Bucket</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Bucket</span> <span class="variable">bucket</span> <span class="operator">=</span> Bucket4j.builder()</span><br><span class="line">            .addLimit(Bandwidth.classic(<span class="number">10</span>, Duration.ofSeconds(<span class="number">1</span>)))</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试消耗一个令牌</span></span><br><span class="line">        <span class="type">ConsumptionProbe</span> <span class="variable">probe</span> <span class="operator">=</span> bucket.tryConsumeAndReturnRemaining(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (probe.isConsumed()) &#123;</span><br><span class="line">            <span class="comment">// 可以处理请求的逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Request processed successfully&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 请求被限流，处理限流逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Request rate limited. Time to wait: &quot;</span> + probe.getNanosToWaitForRefill());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Bucket4j.builder()</code>用于创建一个Bucket的构建器，然后使用<code>addLimit()</code>方法设置限流策略，这里使用了<code>Bandwidth.classic(10, Duration.ofSeconds(1))</code>表示每秒最多处理10个请求。使用<code>tryConsumeAndReturnRemaining(1)</code>方法尝试消耗一个令牌，如果成功消耗则返回一个ConsumptionProbe对象，可以通过该对象判断是否成功消耗以及获取剩余的令牌数。</p><h3 id="分布式限流："><a href="#分布式限流：" class="headerlink" title="分布式限流："></a>分布式限流：</h3><p>有两种思路：</p><p>1）将所有用户访问频率等数据集中存储进行统计，比如使用<code>redis</code>存储，无论用户的请求落到了哪个服务器上，都以集中存储的数据为准。</p><p>2）在网关层面进行限流操作和统计，比如Sentinel、Gateway。</p><h4 id="1-Redisson-RateLimiter"><a href="#1-Redisson-RateLimiter" class="headerlink" title="1. Redisson RateLimiter:"></a>1. Redisson RateLimiter:</h4><p>Redisson RateLimiter是用于分布式限流的一个组件，它基于令牌桶算法，允许你控制在分布式环境中的请求速率。</p><p>参考文档：</p><p><a href="https://redisson.org/glossary/rate-limiter.html">What is a Rate Limiter? | Redisson</a></p><p><a href="https://juejin.cn/post/7203364379339931708">Redisson限流器RRateLimiter使用及源码分析 - 掘金 (juejin.cn)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.redisson.Redisson;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RRateLimiter;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RateIntervalUnit;</span><br><span class="line"><span class="keyword">import</span> org.redisson.api.RedissonClient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Redisson客户端连接</span></span><br><span class="line">        <span class="type">RedissonClient</span> <span class="variable">redisson</span> <span class="operator">=</span> Redisson.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建RateLimiter，每秒产生10个令牌</span></span><br><span class="line">        <span class="type">RRateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> redisson.getRateLimiter(<span class="string">&quot;myRateLimiter&quot;</span>);</span><br><span class="line">        rateLimiter.trySetRate(RateIntervalUnit.SECONDS, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在业务代码中使用RateLimiter进行限流</span></span><br><span class="line">        <span class="keyword">if</span> (rateLimiter.tryAcquire()) &#123;</span><br><span class="line">            <span class="comment">// 处理请求的逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Request processed successfully&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 请求被限流，处理限流逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Request rate limited&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭Redisson客户端连接</span></span><br><span class="line">        redisson.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建了一个Redisson客户端连接，然后通过<code>getRateLimiter</code>方法获取一个分布式限流器实例，设置了每秒产生10个令牌的速率。在业务代码中，通过<code>tryAcquire</code>方法尝试获取一个令牌，如果成功获取则继续处理请求，否则执行限流逻辑。</p><p>注意，上述示例中使用了<code>tryAcquire</code>方法，该方法是非阻塞的。如果需要阻塞等待直到获取到令牌，可以使用<code>acquire</code>方法。</p><h4 id="2-Sentinel"><a href="#2-Sentinel" class="headerlink" title="2. Sentinel:"></a>2. Sentinel:</h4><p>Sentinel是由阿里巴巴开源的分布式系统的流量防卫士。它主要用于实时监控分布式系统的各个节点的健康状况，以及处理各种因节点故障或网络故障引起的异常情况。可以用来做分布式限流，基于流量的 QPS 进行限流。</p><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/363438722">超详细的Sentinel入门 - 知乎 (zhihu.com)</a></p><p><a href="https://springdoc.cn/java-sentinel-intro/">Alibaba Sentinel 简介 - spring 中文网 (springdoc.cn)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.SphU;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 定义资源名称为&quot;myResource&quot;</span></span><br><span class="line">            SphU.entry(<span class="string">&quot;myResource&quot;</span>);</span><br><span class="line">            <span class="comment">// 处理请求的逻辑</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">            <span class="comment">// 请求被限流，处理限流逻辑</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放资源</span></span><br><span class="line">            SphU.exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>常用的限流算法有四种：固定窗口算法、滑动窗口算法、漏桶算法和令牌桶算法，不管哪种算法都需要考虑单位时间即阈值的问题，比较常用的就是令牌桶算法，但是的限流方案还需要结合实际项目去设计。</p><p>单机限流可以用Guava RateLimiter实现，分布式限流可以使用Redisson RateLimiter实现。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 限流算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何解决Twikoo跨域问题</title>
      <link href="/2024/02/16/study-11/"/>
      <url>/2024/02/16/study-11/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注意：解决这个问题只需要去twikoo的管理界面，将跨域配置修改为自己的域名即可，我是最开始填错了，导致废了这么大功夫。。。顺便水了一篇文章。</p></blockquote><p>前面写了一篇跨域问题的解决方案的文章，那篇文章是看了鱼皮老哥视频总结的理论，但是没有实践过，刚好我的博客接入Twikoo评论系统时出现了跨域问题，这几天想着去解决一下这个问题，过程比较艰辛，记录一下。</p><h2 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h2><p>本博客使用的是hexo的butterfly主题，github + Vercel托管，绑定了自定义域名。Twikoo系统使用 Vercel 云函数部署了并绑定了自定义域名。博客在接入Twikoo系统后，本地测试没有问题，可以正常发送评论并推送到邮箱，但是将博客推送上线后，再使用评论时，就会出现跨域问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at <span class="string">&#x27;twikoo自定义域名&#x27;</span> from origin <span class="string">&#x27;我的博客域名&#x27;</span> has been blocked by CORS policy: Response to preflight request doesn<span class="string">&#x27;t pass access control check: No &#x27;</span>Access-Control-Allow-Origin<span class="string">&#x27; header is present on the requested resource.</span></span><br></pre></td></tr></table></figure><h2 id="错误方案："><a href="#错误方案：" class="headerlink" title="错误方案："></a>错误方案：</h2><h3 id="修改请求头："><a href="#修改请求头：" class="headerlink" title="修改请求头："></a>修改请求头：</h3><blockquote><p>注意：解决跨域问题，需要在响应头中加入”Access-Control-Allow-Origin”:”*”，而不是请求头！！！</p><p>缤纷云：<a href="https://console.bitiful.com/buckets">Bitiful</a></p></blockquote><p>因为之前对跨域问题的解决方案理解不够深入，认为解决跨域问题可以在请求头中加入<code>&quot;Access-Control-Allow-Origin&quot;:&quot;*&quot;</code>即可。</p><p>费了点力气去寻找到了Twikoo的main.js文件，然后下载下来，本地修改加入了<code>&quot;Access-Control-Allow-Origin&quot;:&quot;*&quot;</code>请求头：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240216141817060.png" alt="image-20240216141817060"></p><p>然后将这个js文件上传到缤纷云上，再调用这个js文件，结果发现，请求头中是带上了”Access-Control-Allow-Origin”:”*”，但是还是报跨域的错。</p><p>我又去找了文章，发现解决跨域是需要响应头带上Access-Control-Allow-Origin而不是请求头，我也意识到上篇文章写的有点问题，去修改了。</p><h2 id="可能有用的方案："><a href="#可能有用的方案：" class="headerlink" title="可能有用的方案："></a>可能有用的方案：</h2><h3 id="1-使用代理服务器发送请求："><a href="#1-使用代理服务器发送请求：" class="headerlink" title="1. 使用代理服务器发送请求："></a>1. 使用代理服务器发送请求：</h3><p>我就想能不能再发请求的时候带上代理，进行请求转发，于是我去问了ChatGPT，ChatGPT的回答如下：</p><blockquote><p>如果你没有自己的代理服务器，也可以考虑使用一些在线的跨域请求代理服务来解决跨域问题。这些服务将充当中间人，将请求发送到目标服务器并将响应返回给你的应用程序。</p><p>以下是一些常用的在线跨域请求代理服务：</p><ol><li>CORS Anywhere：<a href="https://cors-anywhere.herokuapp.com/">https://cors-anywhere.herokuapp.com/</a></li><li>Ycors：<a href="https://ycors.com/">https://ycors.com/</a></li><li>AnyProxy：<a href="https://anyproxy.io/">https://anyproxy.io/</a></li><li>CORS Proxy：<a href="https://cors-proxy.htmldriven.com/">https://cors-proxy.htmldriven.com/</a></li></ol><p>你可以将你的目标服务器URL放在这些代理服务的URL前面，将请求发送到代理服务，代理服务再将请求发送到目标服务器，并将目标服务器的响应返回给你的应用程序。请注意，这些代理服务可能有使用限制或存活时间限制，所以请查阅相关文档以了解更多详情。</p><p>下面是一段示例代码，展示如何在你的代码中使用 CORS Anywhere 代理解决跨域问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="keyword">var</span> i = <span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;twikoo-access-token&quot;</span>);</span><br><span class="line"> <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line"> o.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="number">4</span> === o.<span class="property">readyState</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="number">200</span> === o.<span class="property">status</span>) &#123;</span><br><span class="line">       <span class="keyword">var</span> n = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(o.<span class="property">responseText</span>);</span><br><span class="line">       n.<span class="property">accessToken</span> &amp;&amp; <span class="variable language_">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;twikoo-access-token&quot;</span>, n.<span class="property">accessToken</span>);</span><br><span class="line">       <span class="title function_">e</span>(&#123; <span class="attr">result</span>: n &#125;);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="title function_">t</span>(o.<span class="property">status</span>);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用 CORS Anywhere 代理发送请求</span></span><br><span class="line"> <span class="keyword">var</span> proxyUrl = <span class="string">&#x27;https://cors-anywhere.herokuapp.com/&#x27;</span> + a;</span><br><span class="line"> o.<span class="title function_">open</span>(<span class="string">&quot;POST&quot;</span>, proxyUrl);</span><br><span class="line"> o.<span class="title function_">setRequestHeader</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line"> o.<span class="title function_">send</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(<span class="title function_">c</span>(&#123; <span class="attr">event</span>: n, <span class="attr">accessToken</span>: i &#125;, r)));</span><br><span class="line">&gt;&#125; <span class="keyword">catch</span> (s) &#123;</span><br><span class="line"> <span class="title function_">t</span>(s);</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>请注意，这些在线代理服务可能会限制访问频率或提供有限的并发连接数。如果你的应用程序需要持续高频率地使用跨域请求，最好考虑搭建自己的代理服务器来更好地控制和管理跨域请求。</p></blockquote><p>然后我就照着替换了这段代码，然后重新上传到缤纷云，但是好像代理并没有起作用，请求还是和原来一样。</p><p>我觉得这个方案是可行的，但是可能由于我的配置不太对，所以代理没有起作用。如果有佬了解这一块可以补充。</p><h3 id="2-使用CDN，添加跨域配置："><a href="#2-使用CDN，添加跨域配置：" class="headerlink" title="2. 使用CDN，添加跨域配置："></a>2. 使用CDN，添加跨域配置：</h3><blockquote><p>国内大部分CDN都需要加速域名备案，因为我没有服务器，所以Twikoo的域名备不了案，如果有可以加速未备案的域名的CDN可以推荐一下。</p><p>这个方法本人并没有尝试成功，我觉得可能是CDN的问题，感兴趣的朋友可以换别的CDN试试。</p><p>缤纷云：<a href="https://console.bitiful.com/buckets">Bitiful</a></p></blockquote><p>这个方案是我之前在某个帖子中看到的，刚好看见缤纷云出了CDN加速功能，就想着去试试。</p><h4 id="操作步骤："><a href="#操作步骤：" class="headerlink" title="操作步骤："></a>操作步骤：</h4><p>首先，将Vercel里绑定的自定义域名去掉，然后在缤纷云的CDN处添加新域名和回源地址和回源HOST（就是Vercel提供的原始域名）：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240216151222217.png" alt="image-20240216151222217"></p><p>然后点击设置-访问控制-跨域访问配置-开启，配置博客网站ip或域名：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240216151408012.png" alt="image-20240216151408012"></p><p>等待部署完成即可。</p><p>到这一步跨域问题已经解决。</p><h4 id="其他问题1：域名未配置证书，访问时被安全拦截"><a href="#其他问题1：域名未配置证书，访问时被安全拦截" class="headerlink" title="其他问题1：域名未配置证书，访问时被安全拦截"></a>其他问题1：域名未配置证书，访问时被安全拦截</h4><blockquote><p>twikoo.xiaoshuzhi.love这个域名的SSL已经配置，忘记截图了，所以用valine.xiaoshuzhi.love来演示。</p></blockquote><p>正常到上面这一步应该已经完成了，但是由于我的域名SSL证书失效了，所以会导致访问域名时被浏览器安全拦截：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240216161726926.png" alt="image-20240216161726926"></p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240216152054516.png" alt="image-20240216152054516"></p><p>这时需要去申请SSL证书，腾讯云可以免费申请1年的SSL证书，然后下载，并且在缤纷云里配置：</p><p>设置-Https配置-开启-更换证书-填写证书内容-选择强制跳转-保存，等待部署完成即可。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240216152529958.png" alt="image-20240216152529958"></p><h4 id="其他问题2：502-bad-Gateway：could-not-connect-to-the-origin-server"><a href="#其他问题2：502-bad-Gateway：could-not-connect-to-the-origin-server" class="headerlink" title="其他问题2：502 bad Gateway：could not connect to the origin server."></a>其他问题2：502 bad Gateway：could not connect to the origin server.</h4><p>这个问题，我在网上搜，答案是Ctrl + F5 刷新就可以解决，但是我试了还是报502，这个问题我怀疑是CDN的问题，后面再去探索。</p><h2 id="终极解决方案："><a href="#终极解决方案：" class="headerlink" title="终极解决方案："></a>终极解决方案：</h2><h3 id="1-twikoo系统有跨域配置："><a href="#1-twikoo系统有跨域配置：" class="headerlink" title="1. twikoo系统有跨域配置："></a>1. twikoo系统有跨域配置：</h3><p>原谅我没有仔细看配置，自己废了这么多力气，原因是最早之前把这个配置填错了，进入Twikoo管理界面-通用，将这个配置填成自己的域名。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240216170951915.png" alt="image-20240216170951915"></p><h3 id="2-更换其他评论系统，比如来必力评论系统："><a href="#2-更换其他评论系统，比如来必力评论系统：" class="headerlink" title="2. 更换其他评论系统，比如来必力评论系统："></a>2. 更换其他评论系统，比如来必力评论系统：</h3><blockquote><p>我在用来必力评论系统之前尝试了Valine评论系统，这个系统也还不错，但是和Twikoo一样，会存在跨域问题，所以选择了来必力。</p><p>Valine国内版好像没有跨域问题，但是需要备案的域名绑定，国际版自定义域名有跨域问题，后面再研究研究。</p></blockquote><p>上面两个方案都是我认为可能有用的方案，但是我尝试时，多少有点问题，所以我暂时妥协了，更换了来必力评论系统，缺点是：必须登录才能评论，界面不好看。优点就一个：使用简单！</p><h3 id="接入来必力评论系统步骤："><a href="#接入来必力评论系统步骤：" class="headerlink" title="接入来必力评论系统步骤："></a>接入来必力评论系统步骤：</h3><p>官网：<a href="https://www.livere.com/">欢迎来到来必力 (livere.com)</a></p><p>韩国的系统，可以用翻译软件翻译为中文。</p><p>注册登录 - 安装 - 选择City版（免费）- 输入网站信息 ，然后会生成代码，复制 UID：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240216163855959.png" alt="image-20240216163855959"></p><p>在_config.butterfly.yml文件中选择Livere评论系统：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240216164006928.png" alt="image-20240216164006928"></p><p>在Livere配置下配置UID即可，非常简单：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240216164158352.png" alt="image-20240216164158352"></p><p>使用起来也没有问题。</p><h2 id="最后："><a href="#最后：" class="headerlink" title="最后："></a>最后：</h2><p>其实关于Twikoo跨域问题，我找了很多资料，都没有提出解决方案的，在官方Github：<a href="https://github.com/twikoojs/twikoo/issues/407">hexo+butterfly 引入 twikoo 后显示访问跨域 · Issue #407 · twikoojs/twikoo (github.com)</a>里有类似的提问，但是好像没找到相关的回答，这篇文章算是一些思路尝试吧。</p><h2 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h2><p>我是傻子，Twikoo有跨域配置，这个问题完全是因为我最开始将跨域配置填错导致的，官方github上有回答，是我没看见，现在文章内容已经更改。</p><p>不过，这次经历确实让我对跨域问题有了更深的理解，也让我明白细心的宝贵！！还有就是有问题可以去官方github上找找答案！</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240216171822825.png" alt="image-20240216171822825"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> Twikoo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何给自己的API提供SDK</title>
      <link href="/2024/01/31/study-8/"/>
      <url>/2024/01/31/study-8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：本文基于<a href="https://www.xiaoshuzhi.love/2024/01/30/study-7/">API签名认证的实现方案 | twigicer’s blog (xiaoshuzhi.love)</a>，模拟接口这部分请阅读上篇文章，本文不再讲述。</p></blockquote><p>在上一篇文章：<a href="https://www.xiaoshuzhi.love/2024/01/30/study-7/">API签名认证的实现方案 | twigicer’s blog (xiaoshuzhi.love)</a>中，编写了模拟接口并进行了模拟调用，也实现了API签名认证保证接口安全性。但是在实际应用中，我们提供的接口应该最大程度的方便开发者调用，例如：不应该让开发者去实现API签名认证的。开发者重点关注的是接口的功能而不是接口的实现，所以我们应该为开发者提供接口SDK，让开发者只需要配置必要参数就可以调用接口。</p><h2 id="SDK简述："><a href="#SDK简述：" class="headerlink" title="SDK简述："></a>SDK简述：</h2><h3 id="什么是SDK"><a href="#什么是SDK" class="headerlink" title="什么是SDK?"></a>什么是SDK?</h3><blockquote><p>以下内容来自于CHatGPT：</p><p>SDK (软件开发工具包) 是一组用于开发特定软件的工具和资源的集合。SDK 包含编译器、库、文档、示例代码和其他支持开发者创建特定软件的组件。SDK 提供了开发者所需的一切，以便他们能够编写、调试和测试软件应用程序。</p></blockquote><p>个人理解：SDK就类似于Utils工具类，简化开发者的开发。</p><h3 id="SDK和API的区别？"><a href="#SDK和API的区别？" class="headerlink" title="SDK和API的区别？"></a>SDK和API的区别？</h3><p>个人理解：API是接口，供开发者调用，而SDK是对API的封装，更加便于开发者调用API.</p><blockquote><p>以下内容来自于CHatGPT：</p><p>SDK（Software Development Kit，软件开发工具包）是一种包含开发特定软件所需工具、库、文档和示例代码的集合。SDK提供了开发者所需的一切，以便他们能够更轻松地创建特定类型的软件。</p><p>API（Application Programming Interface，应用程序编程接口）是一组定义了软件组件之间交互方式的规则和协议。API允许应用程序与其他软件组件（如操作系统、库或服务）进行通信和交互。API定义了如何使用和访问特定软件或服务的功能，而不需要了解其内部实现。</p><p>SDK主要是为了支持软件开发过程，提供工具和资源来编译、构建、测试和调试应用程序。SDK通常包含API，以便开发者能够使用已经定义好的函数和方法来实现特定软件的功能。</p><p>API更侧重于软件组件之间的交互和通信，定义了如何使用和访问特定软件或服务的功能。API描述了使用特定软件或服务提供的函数、类、方法、参数和返回值，使开发者能够利用这些功能进行应用程序的构建。</p><p>总结来说，SDK提供开发工具和资源，帮助开发者创建特定类型的软件，而API定义了软件组件之间的交互规则和访问方式，使得应用程序能够与其他组件进行通信和使用功能。</p></blockquote><h3 id="怎么开发SDk"><a href="#怎么开发SDk" class="headerlink" title="怎么开发SDk?"></a>怎么开发SDk?</h3><p>本文将基于Spring boot starter去实现SDK，差不多就是开发一个starter，类似于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;<span class="number">3.0</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>将上篇文章中的模拟接口、模拟调用和API签名认证功能改为一个依赖包，在pom文件中引入即可调用项目的功能。</p><h3 id="使用SDK（starter）的好处？"><a href="#使用SDK（starter）的好处？" class="headerlink" title="使用SDK（starter）的好处？"></a>使用SDK（starter）的好处？</h3><p>主要就是简化开发，不需要去关注一些不必要的逻辑即可实现功能，在配置参数时也会有一些代码提示。</p><blockquote><p>以下内容来自ChatGPT：</p><ol><li><strong>模块化和可插拔性</strong>： Starter 提供了一种将应用程序拆分成模块的方式。通过将相关功能和配置封装到 Starter 中，可以使应用程序更加模块化，让各个模块之间更加独立、可插拔。这使得你可以更轻松地根据需求添加或删除功能。</li><li><strong>简化配置</strong>： Starter 可以帮助用户轻松配置和集成某个功能。通过提供默认配置和自定义选项，用户可以很容易地调整功能的行为，而无需手动进行复杂的配置。</li><li><strong>减少样板代码</strong>： Starter 可以封装一些常用的代码模板，使得开发者不再需要从头编写重复的代码。这有助于提高代码的复用性，并减少出错的机会。</li><li><strong>易于维护和更新</strong>： 通过将功能封装到 Starter 中，维护者可以更轻松地管理和更新相关代码。这有助于保持项目的健康状态，确保应用程序始终使用最新的、安全的功能。</li><li><strong>降低学习曲线</strong>： Starter 通常提供清晰的文档和示例，帮助使用者更快速地上手。这对于新加入项目的开发者或初学者来说是非常有益的，因为他们可以迅速了解如何使用和配置某个功能。</li><li><strong>社区共享和标准化</strong>： Starter 的使用促进了开发社区中功能的共享和标准化。开发者可以更容易地找到并使用来自社区的 Starter，从而加速项目的开发进程。</li><li><strong>提高开发效率</strong>： 使用 Starter 可以显著提高开发效率。通过引入现成的功能模块，开发者可以专注于业务逻辑，而无需花费大量时间在基础设施和集成细节上。</li></ol></blockquote><h2 id="基于Springboot-starter开发SDK"><a href="#基于Springboot-starter开发SDK" class="headerlink" title="基于Springboot starter开发SDK:"></a>基于Springboot starter开发SDK:</h2><h3 id="1-新建spring项目"><a href="#1-新建spring项目" class="headerlink" title="1. 新建spring项目:"></a>1. 新建spring项目:</h3><p>新建一个springboot项目，type选Maven：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240131120923829.png" alt="image-20240131120923829"></p><p>选择自己需要的依赖，这里演示只需要Lombok，除了项目需要的依赖外，还需要添加：”spring-boot-configuration-processor”依赖，这个依赖可以自动为我们生成代码提示：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-31%20121020.png" alt=""></p><h3 id="2-修改pom文件："><a href="#2-修改pom文件：" class="headerlink" title="2. 修改pom文件："></a>2. 修改pom文件：</h3><p>进入pom文件，修改版本号（也可以不修改，改为0.0.1方便一点，看个人喜好）：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240131121803092.png" alt="image-20240131121803092"></p><p>将<build></build>这块删掉，这块是meven项目构建时用的，而我们开发的SDK不需要，所以直接删掉。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240131122134962.png" alt="image-20240131122134962"></p><p>引入spring初始化模板中没有但是项目需要的依赖，这里需要Hutool依赖，所以直接引入，刷新。</p><h3 id="3-删掉Application启动类："><a href="#3-删掉Application启动类：" class="headerlink" title="3. 删掉Application启动类："></a>3. 删掉Application启动类：</h3><p>因为不需要启动，所以直接将Application 类删掉：</p><p><img src="C:\Users\周斌\AppData\Roaming\Typora\typora-user-images\image-20240131122351687.png" alt="image-20240131122351687"></p><h3 id="4-实现功能接口："><a href="#4-实现功能接口：" class="headerlink" title="4. 实现功能接口："></a>4. 实现功能接口：</h3><p>这里就实现上篇文章中的模拟接口、模拟接口调用、API签名认证，基本上不需要改动什么代码，直接复制粘贴上篇文章项目里的client、model、utils：</p><p>client客户端接口调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwigApiClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TwigApiClient</span><span class="params">(String accessKey, String secretKey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accessKey = accessKey;</span><br><span class="line">        <span class="built_in">this</span>.secretKey = secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; <span class="title function_">getHeaderMap</span><span class="params">(String body)</span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; headerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        headerMap.put(<span class="string">&quot;accessKey&quot;</span>,accessKey);</span><br><span class="line">        <span class="comment">//一定不能直接发送</span></span><br><span class="line"><span class="comment">//        headerMap.put(&quot;secretKey&quot;,secretKey);</span></span><br><span class="line">        headerMap.put(<span class="string">&quot;body&quot;</span>,body);</span><br><span class="line">        headerMap.put(<span class="string">&quot;nonce&quot;</span>, RandomUtil.randomNumbers(<span class="number">4</span>));</span><br><span class="line">        headerMap.put(<span class="string">&quot;timestamp&quot;</span>,String.valueOf(System.currentTimeMillis()/<span class="number">1000</span>));</span><br><span class="line">        headerMap.put(<span class="string">&quot;sign&quot;</span>, SignUtils.genSign(body,secretKey));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> headerMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserNameByPost</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONUtil.toJsonStr(user);</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> HttpRequest.post(<span class="string">&quot;http://localhost:8201/api/name/user&quot;</span>)</span><br><span class="line">                .body(json)</span><br><span class="line">                .addHeaders(getHeaderMap(json))</span><br><span class="line">                .execute();</span><br><span class="line">        System.out.println(httpResponse.getStatus());</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> httpResponse.body();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>model的User：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>utils的签名生成算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SignUtils</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成签名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> body</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">genSign</span><span class="params">(String body,String secretKey)</span>&#123;</span><br><span class="line">        <span class="type">Digester</span> <span class="variable">digester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Digester</span>(DigestAlgorithm.SHA256);</span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> body + <span class="string">&quot;.&quot;</span> + secretKey;</span><br><span class="line">        <span class="keyword">return</span> digester.digestHex(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-写ClientConfig-配置类："><a href="#5-写ClientConfig-配置类：" class="headerlink" title="5. 写ClientConfig 配置类："></a>5. 写ClientConfig 配置类：</h3><p>SDK需要一个配置类来描述实例的生成配置，用@Bean产生对象并交给spring管理，@Configuration表明这是个配置类并交于spring管理，@ComponentScan允许包扫描，@Data生成构造函数，比较重要的是：@ConfigurationProperties(“twig.client”)用于将配置文件中”twig.client”开头的属性绑定到POJO中，也就是在后面我们调用这个依赖写配置文件时会给我们提示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(&quot;twig.client&quot;)</span></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwigApiClientConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TwigApiClient <span class="title function_">twigApiClient</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TwigApiClient</span>(accessKey,secretKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-新建META-INF目录与spring-factories文件："><a href="#6-新建META-INF目录与spring-factories文件：" class="headerlink" title="6. 新建META-INF目录与spring.factories文件："></a>6. 新建META-INF目录与spring.factories文件：</h3><p>在resources目录下新建META-INF目录和spring.factories文件：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240131124541204.png" alt="image-20240131124541204"></p><p>并在spring.factories文件中写入：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.twigicer.twigapiclientsdk.TwigApiClientConfig</span><br></pre></td></tr></table></figure><p>这块涉及springboot自动配置的原理，就是为了spring可以扫描到第三方类，可以参考：</p><p><a href="https://blog.csdn.net/nsplnpbjy/article/details/106465719">springboot自动配置原理以及spring.factories文件的作用_springboot自动配置是读取什么文件-CSDN博客</a></p><p><a href="https://zhuanlan.zhihu.com/p/444331676">springboot核心基础之spring.factories机制 - 知乎 (zhihu.com)</a></p><h3 id="7-使用meven打包："><a href="#7-使用meven打包：" class="headerlink" title="7. 使用meven打包："></a>7. 使用meven打包：</h3><p>使用maven的install或者package进行打包：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240131125449789.png" alt="image-20240131125449789"></p><p>这个时候会报错：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240131125559789.png" alt="image-20240131125559789"></p><p>很正常，因为我们删除了Application启动类，但是在test包中还有这个类的测试类，而在meven打包前有个test步骤，会走一次测试，如果测试类里有报错，或者测试失败都会导致打包失败。</p><p>解决方法：</p><ol><li><p>直接删除test包或者test包中的ApplicationTests启动测试类:</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240131125949650.png" alt="image-20240131125949650"></p></li><li><p>点击下面这个按钮，排除meven生命周期的test阶段：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240131130207282.png" alt="image-20240131130207282"></p></li></ol><p>再次打包，看到提示”build success”，打包成功：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240131130309129.png" alt="image-20240131130309129"></p><p>到此，SDK开发结束。</p><h2 id="调用测试SDK"><a href="#调用测试SDK" class="headerlink" title="调用测试SDK:"></a>调用测试SDK:</h2><p>在接口项目中调用测试一下该SDK是否生效：</p><h3 id="1-引入SDK依赖："><a href="#1-引入SDK依赖：" class="headerlink" title="1. 引入SDK依赖："></a>1. 引入SDK依赖：</h3><p>在接口项目的pom文件中引入刚才打好的包（就是引入SDK项目pom文件中的groupId、artifactId和version）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;com.twigicer&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;demo-sdk&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;<span class="number">0.0</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>刷新。</p><h3 id="2-修改配置文件的AK-SK："><a href="#2-修改配置文件的AK-SK：" class="headerlink" title="2. 修改配置文件的AK/SK："></a>2. 修改配置文件的AK/SK：</h3><p>在yml文件里配置accessKey和secretKey，可以看到这时会有代码提示：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240131131251659.png" alt="image-20240131131251659"></p><h3 id="3-修改模拟接口的User、SignUtil路径为依赖包路径："><a href="#3-修改模拟接口的User、SignUtil路径为依赖包路径：" class="headerlink" title="3. 修改模拟接口的User、SignUtil路径为依赖包路径："></a>3. 修改模拟接口的User、SignUtil路径为依赖包路径：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import com.twigicer.demosdk.model.User;</span><br><span class="line">import com.twigicer.demosdk.utils.SignUtils;</span><br><span class="line">import jakarta.servlet.http.HttpServletRequest;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/name&quot;)</span><br><span class="line">public class NameController &#123;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;/user&quot;)</span><br><span class="line">    public String getUserNameByPost(@RequestBody User user, HttpServletRequest request)&#123;</span><br><span class="line">        String accessKey = request.getHeader(&quot;accessKey&quot;);</span><br><span class="line">        String nonce = request.getHeader(&quot;nonce&quot;);</span><br><span class="line">        String timestamp = request.getHeader(&quot;timestamp&quot;);</span><br><span class="line">        String sign = request.getHeader(&quot;sign&quot;);</span><br><span class="line">        System.out.println(sign);</span><br><span class="line">        String body = request.getHeader(&quot;body&quot;);</span><br><span class="line">        if(!accessKey.equals(&quot;twig&quot;) )&#123;</span><br><span class="line">            throw new RuntimeException(&quot;无权限&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(Long.parseLong(nonce) &gt; 10000)&#123;</span><br><span class="line">            throw new RuntimeException(&quot;无权限&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // TODO 校验时间和当前时间相差不能超过5分钟</span><br><span class="line">//        if(timestamp ...)&#123;</span><br><span class="line">//</span><br><span class="line">//        &#125;</span><br><span class="line">        String visitSign = SignUtils.genSign(body, &quot;abcdefgh&quot;);</span><br><span class="line">        if(!sign.equals(visitSign))&#123;</span><br><span class="line">            throw new RuntimeException(&quot;无权限&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return &quot;Post 你的名字是：&quot; + user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-编写测试类："><a href="#4-编写测试类：" class="headerlink" title="4. 编写测试类："></a>4. 编写测试类：</h3><p>编写测试类进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"> <span class="keyword">private</span> TwigApiClient twigApiClient;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">     user.setUserName(<span class="string">&quot;twig&quot;</span>);</span><br><span class="line">     <span class="type">String</span> <span class="variable">usernameByPost</span> <span class="operator">=</span> twigApiClient.getUserNameByPost(user);</span><br><span class="line">     System.out.println(usernameByPost);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>测试结果，调用成功：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240131132758399.png" alt="image-20240131132758399"></p><h2 id="打好的包放在哪？"><a href="#打好的包放在哪？" class="headerlink" title="打好的包放在哪？"></a>打好的包放在哪？</h2><p>到这有没有疑惑，为什么打的包在别的项目中可以直接引入？打好的包放在了哪里？</p><p>这个包放在了本地的仓库中，一般在C盘的用户文件夹里的.m2文件里，但是我的放在了E盘，我也不太清楚为什么。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240131133528849.png" alt="image-20240131133528849"></p><p>如果想让别人使用这个依赖包，可以直接把jar包给他，也可以将jar包上传到meven中心仓库中，至于怎么上传，暂时不太了解，可以自行百度。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>开发SDK有7步：创项目 -&gt; 修改pom -&gt; 删除启动类 -&gt; 实现功能 -&gt; 写配置类 -&gt; 创建spring.factories文件 -&gt; 打包。注意打包时排除掉test阶段。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>API签名认证的实现方案</title>
      <link href="/2024/01/30/study-7/"/>
      <url>/2024/01/30/study-7/</url>
      
        <content type="html"><![CDATA[<p>在搭建这个小破站的过程中调用了一些第三方API，比如公告栏的欢迎就调用了腾讯地图的API；如果想加天气可以去调用和风天气的API；为了防止用户频繁调用这些API，也为了做一些统计和计费，所以在调用这些API时都需要我们去申领一个Key，而这个Key就是本文要说的签名。</p><h2 id="API签名认证简介："><a href="#API签名认证简介：" class="headerlink" title="API签名认证简介："></a>API签名认证简介：</h2><h3 id="什么是API签名认证？"><a href="#什么是API签名认证？" class="headerlink" title="什么是API签名认证？"></a>什么是API签名认证？</h3><blockquote><p>以下内容来自ChatGPT：</p><p>API签名认证是一种用于验证API请求的身份和完整性的安全机制。在使用API时，通常需要发送HTTP请求来获取或操作数据。为了确保请求的合法性和安全性，API签名认证采用了一种算法（例如HMAC-SHA256），使用密钥对请求参数和其他相关信息进行哈希或加密，生成一个唯一的签名字符串。接收方在收到API请求后，使用相同的算法和密钥对请求参数进行处理，并与请求中的签名字符串进行比较。如果两者一致，则表明请求是合法的，否则请求将被认为是伪造或篡改的。这种认证方法可以有效防止恶意请求和数据篡改，提高API的安全性。</p></blockquote><p>个人理解：类似于session，在用户登录时为用户分发一个session,需要做一些操作时，需要根据session去鉴权；而API签名认证类似，为用户分发一个签名，在用户调用API时，会判断签名是否正确去鉴权，判断是否允许调用。</p><h3 id="为什么需要API签名认证？"><a href="#为什么需要API签名认证？" class="headerlink" title="为什么需要API签名认证？"></a>为什么需要API签名认证？</h3><p>主要是防止API被无限制的调用，保证接口的安全性，看看专业术语：</p><blockquote><p>以下内容来自ChatGPT：</p><ol><li>身份验证：API签名认证可以验证请求的发送者是否具有合法的身份。通过使用密钥和算法对请求进行签名，可以确保只有具有有效密钥的授权用户才能发送请求。这样可以防止未经授权的用户访问和使用API。</li><li>完整性验证：API签名认证可以验证请求的完整性，即请求参数是否被篡改。通过将请求参数与签名字符串进行比较，可以确定请求是否在传输过程中被篡改。这可以防止中间人攻击和数据篡改。</li><li>防止重放攻击：API签名认证可以防止恶意用户重放之前的有效请求。通过在签名过程中包含时间戳或随机数等参数，可以确保请求不能被多次重放。这有助于提高系统的安全性和稳定性。</li><li>数据保护：API签名认证可以保护API传输的数据。通过使用加密算法对请求进行签名，可以防止敏感数据在传输过程中被窃取或篡改。</li></ol></blockquote><h2 id="API签名认证的实现："><a href="#API签名认证的实现：" class="headerlink" title="API签名认证的实现："></a>API签名认证的实现：</h2><h3 id="1-AccessKey和SecretKey实现："><a href="#1-AccessKey和SecretKey实现：" class="headerlink" title="1. AccessKey和SecretKey实现："></a>1. <strong>AccessKey</strong>和<strong>SecretKey</strong>实现：</h3><p>主要步骤就两个：签发签名和校验签名。</p><p>为开发者分配<strong>AccessKey</strong>和<strong>SecretKey</strong>，为了安全，尽量复杂，无序，无规律。</p><p>AccessKey：调用的标识：userA，userB</p><p>SecretKey：密钥</p><p>类似于账号和密码，但是用户名和密码只需要登录一次就可以在后续操作中可以一直使用，但是<strong>AccessKey</strong>和<strong>SecretKey</strong>是无状态的，每次使用都需要带着。</p><p>在用户调用接口时，需要在请求头中发送签名，然后查询数据库，判断签名是否一致，一致则允许调用，不一致则不允许调用。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><blockquote><p>为了方便演示，先将Accesskey和SecretKey写死为”twig”和”abcdefgh”。实际应该在数据库的用户表中插入这两个字段，然后为用户签发签名后将两个字段存入数据库，校验时从库里查询是否一致。</p></blockquote><p>编写一个User类，方便传参，只写一个userName，使用Lombok：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写模拟接口并添加签名校验的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/name&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NameController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserNameByPost</span><span class="params">(<span class="meta">@RequestBody</span> User user, HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessKey</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;accessKey&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">secretKey</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;secretKey&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//实际使用时在数据库中查询accessKey和secretKey并校验</span></span><br><span class="line">        <span class="keyword">if</span>(!accessKey.equals(<span class="string">&quot;twig&quot;</span>) || !secretKey.equals(<span class="string">&quot;abcdefgh&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;无权限&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Post 你的名字是：&quot;</span> + user.getUserName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写调用第三方接口的客户端,，使用了Hutool工具包的http请求工具：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwigApiClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TwigApiClient</span><span class="params">(String accessKey, String secretKey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.accessKey = accessKey;</span><br><span class="line">        <span class="built_in">this</span>.secretKey = secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求头参数</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; <span class="title function_">getHeaderMap</span><span class="params">()</span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; headerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        headerMap.put(<span class="string">&quot;accessKey&quot;</span>,accessKey);</span><br><span class="line">        headerMap.put(<span class="string">&quot;secretKey&quot;</span>,secretKey);</span><br><span class="line">        <span class="keyword">return</span> headerMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用接口</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserNameByPost</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONUtil.toJsonStr(user);</span><br><span class="line">        <span class="type">HttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> HttpRequest.post(<span class="string">&quot;http://localhost:8201/api/name/user&quot;</span>)</span><br><span class="line">                .body(json)</span><br><span class="line">                .addHeaders(getHeaderMap())</span><br><span class="line">                .execute();</span><br><span class="line">        <span class="comment">//打印状态码</span></span><br><span class="line">        System.out.println(httpResponse.getStatus());</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> httpResponse.body();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写测试类，这里直接用main方法测试，在创建客户端对象时传入accessKey和secretKey，先传入正确的”twig”和”abcdefgh”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在创建客户端对象时传入accessKey和secretKey</span></span><br><span class="line">        <span class="type">TwigApiClient</span> <span class="variable">twigApiClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwigApiClient</span>(<span class="string">&quot;twig&quot;</span>,<span class="string">&quot;abcdefgh&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserName(<span class="string">&quot;twigicer&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">res3</span> <span class="operator">=</span> twigApiClient.getUserNameByPost(user);</span><br><span class="line">        System.out.println(res3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面传入了正确的accessKey和secretKey，所以可以正常调用到接口：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240130134831198.png" alt="image-20240130134831198"></p><p>如果在创建客户端时,传入错误的accessKey或者secretKey，则调用失败：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240130135108182.png" alt="image-20240130135108182"></p><h2 id="2-改进方案："><a href="#2-改进方案：" class="headerlink" title="2. 改进方案："></a>2. 改进方案：</h2><p>上面的方法是不安全的，因为直接把accessKey和secretKey放在了请求头里，但是请求是可能被拦截的，被拦截之后，就可以使用我们的accessKey和secretKey去发请求，所以我们<strong>一定不能把密钥直接在服务器之间传递！！！</strong></p><p>我们可以将accessKey和secretKey通过签名算法加密为sig(签名)，传递sign而不传递accessKey和secretKey。</p><p>accessKey + secretKey =&gt; <strong>签名生成算法</strong> =&gt; 不可解密的sign (签名)<br>twig + abcdefgh =&gt; ahcch16763661hcdgykl（不可解密）</p><h3 id="sign是不可解密的，那怎么去做校验呢？"><a href="#sign是不可解密的，那怎么去做校验呢？" class="headerlink" title="sign是不可解密的，那怎么去做校验呢？"></a>sign是不可解密的，那怎么去做校验呢？</h3><p>类似于数据库用户名和密码的加密和解密，因为accessKey和secretKey是服务端颁发的，记录在数据库里，服务端在校验时，查询到accessKey和secretKey，再利用上述同样的签名算法进行加密后，对比与sign是否一致即可。</p><h3 id="重放风险："><a href="#重放风险：" class="headerlink" title="重放风险："></a>重放风险：</h3><p>但是上面这种方法还存在被重放的风险。</p><h4 id="什么是重放？"><a href="#什么是重放？" class="headerlink" title="什么是重放？"></a>什么是重放？</h4><blockquote><p>以下内容来自ChatGPT:</p><p>重放攻击是一种网络安全攻击，其基本原理是攻击者截获网络通信中的数据包，并在稍后的某个时间重新发送这些数据包，以模拟合法用户的行为。这种攻击通常针对那些未经充分保护的通信协议或系统，攻击者可以通过重放合法用户的认证凭证或请求来获取未经授权的访问权限或执行某些未经授权的操作。</p><p>重放攻击可以针对各种类型的系统和协议，包括但不限于网络身份验证系统、API接口、加密通信等。攻击者通过截获合法用户的认证凭证、会话令牌或其他敏感数据，然后重新发送这些数据以获取对系统的未经授权访问。例如，在网络身份验证中，攻击者可能截获用户的用户名和密码，然后将这些凭据重新发送到服务器以获得对用户账户的访问权限。</p></blockquote><p>简单来说重放就是：重复使用请求参数伪造二次请求。</p><p>实现重放也很简单，如下图，点击”重播XHR”，就可以再发一次请求：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240130142504596.png" alt="image-20240130142504596"></p><h4 id="怎么防重放？"><a href="#怎么防重放？" class="headerlink" title="怎么防重放？"></a>怎么防重放？</h4><ol><li>加nonce随机数，每个随机数只能使用一次，弊端是服务端需要记录每次的随机数。</li><li>加timestamp时间戳，校验时间戳是否过期，弊端是再时间戳未过期时还是会被重放。</li><li>nonce和timestamp配合使用，在时间戳未过期时加随机数校验，时间戳过期时清空随机数，这样可以解决单一使用时的弊端。</li></ol><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/220033777">开放API接口签名验证，让你的接口从此不再裸奔 - 知乎 (zhihu.com)</a></p><blockquote><p>nonce指唯一的随机字符串，用来标识每个被签名的请求。通过为每个请求提供一个唯一的标识符，服务器能够防止请求被多次使用（记录所有用过的nonce以阻止它们被二次使用）。</p><p>然而，对服务器来说永久存储所有接收到的nonce的代价是非常大的。可以使用timestamp来优化nonce的存储。</p><p>假设允许客户端和服务端最多能存在15分钟的时间差，同时追踪记录在服务端的nonce集合。当有新的请求进入时，首先检查携带的timestamp是否在15分钟内，如超出时间范围，则拒绝，然后查询携带的nonce，如存在已有集合，则拒绝。否则，记录该nonce，并删除集合内时间戳大于15分钟的nonce（可以使用redis的expire，新增nonce的同时设置它的超时失效时间为15分钟）。</p></blockquote><h2 id="3-最终实现方案："><a href="#3-最终实现方案：" class="headerlink" title="3. 最终实现方案："></a>3. 最终实现方案：</h2><p>所以一次标准的API签名认证实现，需要上述的所有参数和用户的请求参数：</p><ul><li>参数1：AccessKey</li><li>参数2：SecretKey  //该参数不传递到请求头中</li><li>参数3：用户的请求参数</li><li>参数4：sign</li><li>参数5：nonce</li><li>参数6：timestamp</li></ul><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><blockquote><p>为了方便演示，先将Accesskey和SecretKey写死为”twig”和”abcdefgh”。实际应该在数据库的用户表中插入这两个字段，然后为用户签发签名后将两个字段存入数据库，校验时从库里查询是否一致。</p></blockquote><p>在请求头中放入上述参数，注意：secretKe一定不能直接放在请求头中！！！！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; <span class="title function_">getHeaderMap</span><span class="params">(String body)</span>&#123;</span><br><span class="line">        Map&lt;String,String&gt; headerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        headerMap.put(<span class="string">&quot;accessKey&quot;</span>,accessKey);</span><br><span class="line">        <span class="comment">//一定不能直接发送</span></span><br><span class="line"><span class="comment">//        headerMap.put(&quot;secretKey&quot;,secretKey);</span></span><br><span class="line">        headerMap.put(<span class="string">&quot;body&quot;</span>,body);</span><br><span class="line">        headerMap.put(<span class="string">&quot;nonce&quot;</span>, RandomUtil.randomNumbers(<span class="number">4</span>));</span><br><span class="line">        headerMap.put(<span class="string">&quot;timestamp&quot;</span>,String.valueOf(System.currentTimeMillis()/<span class="number">1000</span>));</span><br><span class="line">        headerMap.put(<span class="string">&quot;sign&quot;</span>, SignUtils.genSign(body,secretKey));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> headerMap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>编写一个签名生成算法类（这里使用的时huTool的工具包）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">genSign</span><span class="params">(String body,String secretKey)</span>&#123;</span><br><span class="line">    <span class="type">Digester</span> <span class="variable">digester</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Digester</span>(DigestAlgorithm.SHA256);</span><br><span class="line">    <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> body + <span class="string">&quot;.&quot;</span> + secretKey;</span><br><span class="line">    <span class="keyword">return</span> digester.digestHex(content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用接口方法和之前一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getUserNameByPost</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSONUtil.toJsonStr(user);</span><br><span class="line">    <span class="type">HttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> HttpRequest.post(<span class="string">&quot;http://localhost:8201/api/name/user&quot;</span>)</span><br><span class="line">            .body(json)</span><br><span class="line">            .addHeaders(getHeaderMap(json))</span><br><span class="line">            .execute();</span><br><span class="line">    System.out.println(httpResponse.getStatus());</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> httpResponse.body();</span><br><span class="line">    System.out.println(res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在接口中校验参数和签名，时间戳校验可以使用redis，注意：这里visitSign生成方法要和之前sign生成方法一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@PostMapping(&quot;/user&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserNameByPost</span><span class="params">(<span class="meta">@RequestBody</span> User user, HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">accessKey</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;accessKey&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">nonce</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;nonce&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">timestamp</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;timestamp&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sign</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;sign&quot;</span>);</span><br><span class="line">        System.out.println(sign);</span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;body&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!accessKey.equals(<span class="string">&quot;twig&quot;</span>) )&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;无权限&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Long.parseLong(nonce) &gt; <span class="number">10000</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;无权限&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// TODO 校验时间和当前时间相差不能超过5分钟</span></span><br><span class="line"><span class="comment">//        if(timestamp ...)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">visitSign</span> <span class="operator">=</span> SignUtils.genSign(body, <span class="string">&quot;abcdefgh&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(!sign.equals(visitSign))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;无权限&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Post 你的名字是：&quot;</span> + user.getUserName();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>编写测试类，和之前一样直接用mian方法测试，先传入正确的”twig”和”abcdefgh”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//在创建客户端对象时传入accessKey和secretKey</span></span><br><span class="line">        <span class="type">TwigApiClient</span> <span class="variable">twigApiClient</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TwigApiClient</span>(<span class="string">&quot;twig&quot;</span>,<span class="string">&quot;abcdefgh&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUserName(<span class="string">&quot;twigicer&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">res3</span> <span class="operator">=</span> twigApiClient.getUserNameByPost(user);</span><br><span class="line">        System.out.println(res3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面传入了正确的accessKey和secretKey，所以可以正常调用到接口：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-30%20163836.png" alt=""></p><p>如果在创建客户端时,传入错误的accessKey或者secretKey，则调用失败：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240130165055136.png" alt="image-20240130165055136"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>API签名认证是一个很灵活的设计，本文只是记录较为规范的实现方式，具体实现需要根据实际业务场景去设计。</p><p>参考文章：</p><p><a href="https://zhuanlan.zhihu.com/p/220033777">开放API接口签名验证，让你的接口从此不再裸奔 - 知乎 (zhihu.com)</a></p><p>鱼皮老哥：<a href="https://www.code-nav.cn/">主页 - 编程导航 (code-nav.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> API签名认证 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何解决Idea使用git push时连接不上服务器</title>
      <link href="/2024/01/28/study-4/"/>
      <url>/2024/01/28/study-4/</url>
      
        <content type="html"><![CDATA[<p>之前有记录过一个相似的问题，但是由于上一代博客没有做好备份，这篇文章也是成功被我弄丢了。。。哎，都是经验和教训。</p><h2 id="问题简述："><a href="#问题简述：" class="headerlink" title="问题简述："></a>问题简述：</h2><p>先说说这次的问题：在Idea里搭好项目的基本框架后，像往常一样 “Share Project on Github”, 结果报错了，报错信息忘记保存了，但大概意思是：GitHub仓库搭建完成，但是项目提交失败。我去仓库看确实只有仓库，没有代码。于是我就准备自己再 push 一次，但是还是报错了（试了三次，项目名不太方便放，可以自行去我的仓库看）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/twigIcer/xxx.git/&#x27;: Failed to connect to github.com port 443 after 38150 ms: Couldn&#x27;t connect to server</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/1.png" alt=""></p><h2 id="探究过程："><a href="#探究过程：" class="headerlink" title="探究过程："></a>探究过程：</h2><h3 id="1-关闭代理："><a href="#1-关闭代理：" class="headerlink" title="1. 关闭代理："></a>1. 关闭代理：</h3><p>我一看 “443”，这不是我上次记录的问题嘛，我记得和代理有关，好像关闭代理就可以了，于是上网一搜，果然有这个答案：</p><p><a href="https://blog.csdn.net/good_good_xiu/article/details/118567249">git提交或克隆报错fatal: unable to access ‘https://github.com/tata20191003/autowrite.git/‘: Failed to connec-CSDN博客</a></p><p>解决方案是取消代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//取消http代理</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">//取消https代理 </span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>但是关闭后还是报同样的错误。</p><blockquote><p>后来仔细一看，人家的报错是 “fatal: unable to access ‘<a href="https://github.com/xxx/autowrite.git/">https://github.com/xxx/autowrite.git/</a>‘: Failed to connect to github.com port 443: Timed out” ,连接超时，而我的报错是连接不上服务器。</p></blockquote><h3 id="2-关闭魔法："><a href="#2-关闭魔法：" class="headerlink" title="2. 关闭魔法："></a>2. 关闭魔法：</h3><p>我就在想是不是由于我开了魔法，但是刚才又关闭了代理，所以导致 push 又被墙了。</p><p>可是关闭了我的魔法后，还是报一样的错误。</p><h3 id="3-关闭本机代理："><a href="#3-关闭本机代理：" class="headerlink" title="3. 关闭本机代理："></a>3. 关闭本机代理：</h3><p>后面我又看到一个答案是说，可以去关闭电脑的代理（文章链接找不到了，抱歉），”设置-网络和Internet-使用代理服务器的编辑按钮-关闭-保存”。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-01-28%20125614.png" alt=""></p><p>可是很遗憾，还是不可以。</p><h3 id="4-尝试其他IDE"><a href="#4-尝试其他IDE" class="headerlink" title="4. 尝试其他IDE:"></a>4. 尝试其他IDE:</h3><p>我都在想是不是我的 git 出问题了，于是在 WebStorm 里尝试把前端部分提交上传，结果成功了，很显然是Idea的问题。</p><h2 id="正解："><a href="#正解：" class="headerlink" title="正解："></a>正解：</h2><p>于是我就先放下这个问题了，但是这个问题不解决，总感觉难受，直到我看到了正确解决方案：</p><p><a href="https://cloud.tencent.com/developer/article/2221680">git clone出现 fatal: unable to access ‘https://github.com/…’的解决办法(亲测有效)-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>我使用了上面这篇文章的解决方案二，手动配置git的代理。先将上面试错时关闭的本机代理重新开启，然后可以看到代理的Ip地址和端口，在 git bash 或者 Idea 终端用下面的命令指定代理即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 使用时将ip和端口换为自己的</span><br><span class="line">git config --global http.proxy http://127.0.0.1:7890 </span><br><span class="line"></span><br><span class="line">git config --global https.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>然后再次 push ，发现报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: unable to access &#x27;https://github.com/twigIcer/xxx.git/&#x27;: Recv failure: Connection was reset</span><br></pre></td></tr></table></figure><p>连接重置，这个问题很常见了，重试就行了，于是重新 push ，成功推送，github仓库里也有了代码，问题解决。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>由于国内的限制，访问 github 需要开魔法，开了魔法可能导致Idea记录的的 ip和端口与代理服务器ip 端口不一致的情况，这时候就需要修改代理或者关闭代理。上次记录的问题是上面试错第一个，连接超时的问题，这个问题可以关闭代理来解决。而这次报错是连接不上服务器 443 端口 ，就需要去修改代理IP和端口与本机一致。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何解决跨域问题</title>
      <link href="/2024/01/24/study-6/"/>
      <url>/2024/01/24/study-6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注意：本文重点并不是解决引入twikoo到博客的跨域问题，只是作为例子引出跨域问题！！</p></blockquote><p>前几天在部署twikoo评论系统到博客的时候，遇到了经典跨域问题，报错信息如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at <span class="string">&#x27;twikoo网址&#x27;</span> from origin <span class="string">&#x27;我的服务器ip&#x27;</span> has been blocked by CORS policy: Response to preflight request doesn<span class="string">&#x27;t pass access control check: No &#x27;</span>Access-Control-Allow-Origin<span class="string">&#x27; header is present on the requested resource.</span></span><br></pre></td></tr></table></figure><p>看见”CORS” 和 “Access-Control-Allow-Origin”基本可以确定是跨域问题了，但是由于twikoo解决跨域问题比较复杂，需要在服务里去修改或者利用CDN加请求头，后面可能会把域名换一致去解决。</p><p>今天看鱼皮视频时，看见他把跨域问题讲的很清楚，这篇文章做个总结记录。</p><h2 id="跨域问题："><a href="#跨域问题：" class="headerlink" title="跨域问题："></a>跨域问题：</h2><h3 id="什么是跨域问题："><a href="#什么是跨域问题：" class="headerlink" title="什么是跨域问题："></a>什么是跨域问题：</h3><p>以下解释来自chatGPT:</p><blockquote><p>跨域问题指的是在网页中，当一个域名下的网页通过AJAX、Fetch或Web Socket等方式向另一个域名下的接口发送跨域请求时所遇到的限制和问题。同源策略是浏览器的一种安全策略，它规定了一个网页只能从相同的协议（如http、https）、域名和端口请求资源，而不能直接访问其他域名下的资源。</p><p>跨域问题的出现是为了确保用户的信息安全和保护网站的数据。但是，在实际的开发中，有时需要在不同的域名之间进行数据交互，这时就会遇到跨域问题。</p></blockquote><p>个人觉得鱼皮的解释更简洁清楚：</p><blockquote><p>浏览器为了用户的安全，仅允许同域名、同端口的服务器发送请求。</p></blockquote><p>如果服务器域名和端口不同就会发生跨域问题。</p><h3 id="预检请求："><a href="#预检请求：" class="headerlink" title="预检请求："></a><strong>预检请求</strong>：</h3><p>跨域预检请求（Cross-Origin Resource Sharing Pre-flight Request）是指在发送真正的跨域请求之前，浏览器会发送一个OPTIONS请求来向服务器获取权限，以确定是否能够发送跨域请求。</p><p>当满足以下条件之一时，浏览器会发送预检请求：</p><ol><li>使用非简单请求方法，如PUT、DELETE等。</li><li>使用非简单请求头部，如自定义的Content-Type、Authorization等。</li><li>其他需要进行预检的情况。</li></ol><p>预检请求的过程如下：</p><ol><li>浏览器自动发送一个OPTIONS请求，向目标服务器询问是否允许发送跨域请求。</li><li>服务器收到OPTIONS请求后，根据请求的头部信息（如Origin、Access-Control-Request-Method、Access-Control-Request-Headers等）进行验证和处理。</li><li>服务器根据验证结果，在响应头部中返回相应的信息给浏览器，以告知是否允许发送跨域请求。<ul><li>如果服务器允许跨域请求，响应头部会包含类似于<code>Access-Control-Allow-Origin: *</code>或<code>Access-Control-Allow-Methods: POST, GET, OPTIONS</code>的字段。</li><li>如果服务器不允许跨域请求，响应头部会不包含上述字段，或者返回错误码。</li></ul></li></ol><p>只有在服务器返回正确的响应头部信息后，浏览器才会根据服务器的允许策略决定是否继续发送真正的跨域请求。</p><h2 id="如何解决跨域问题："><a href="#如何解决跨域问题：" class="headerlink" title="如何解决跨域问题："></a>如何解决跨域问题：</h2><p>有两种思路：</p><ol><li>把域名、端口改为相同的。</li><li>让服务器告诉浏览器，允许跨域，也就是返回”Access-Control-Allow-Origin”响应头。</li></ol><h3 id="把域名、端口改为相同："><a href="#把域名、端口改为相同：" class="headerlink" title="把域名、端口改为相同："></a>把域名、端口改为相同：</h3><p>这是最直观的解决方案，上面解决twikoo跨域问题我有可能会用这个方案。</p><p>但是一般前后端分离项目，用的端口都会不同，这个时候就需要用到：用<strong>代理服务器</strong>来将请求转发到同一个域名下。</p><h4 id="什么是代理服务器："><a href="#什么是代理服务器：" class="headerlink" title="什么是代理服务器："></a>什么是代理服务器：</h4><p>代理服务器：是一种位于客户端和目标服务器之间的服务器，用于转发客户端的请求并将目标服务器的响应返回给客户端。通过配置代理服务器，可以在客户端和目标服务器之间建立中间层，从而解决跨域问题。</p><blockquote><p>代理服务器与服务器之间是非同源，但不存在跨域问题，是因为服务器之间采用的是http请求，而不是ajax技术。</p></blockquote><p><img src="C:\Users\周斌\AppData\Roaming\Typora\typora-user-images\image-20240123165649972.png" alt="image-20240123165649972"></p><h4 id="代理服务器解决跨域："><a href="#代理服务器解决跨域：" class="headerlink" title="代理服务器解决跨域："></a>代理服务器解决跨域：</h4><blockquote><p>本菜鸟主攻后端，如果前端部分说的有问题，欢迎指正。</p></blockquote><p>像主流的前端框架，像 Vue 和 React 都内置了代理，只需要修改配置即可，比较简单，用的比较多的还用Nginx服务器作为代理服务器转发请求。</p><p>参考文章：<a href="https://zhuanlan.zhihu.com/p/132534931">10 种跨域解决方案（附终极方案） - 知乎 (zhihu.com)</a></p><p><strong>Vue框架：</strong></p><p>在<code>vue.config.js</code>文件中添加如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    proxy: &#123;</span><br><span class="line">      &#x27;/api&#x27;: &#123;</span><br><span class="line">        target: &#x27;http://example.com&#x27;, // 目标接口的域名</span><br><span class="line">        changeOrigin: true, // 是否改变源</span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          &#x27;^/api&#x27;: &#x27;&#x27; // 路径重写</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述配置中使用了<code>proxy</code>选项，将请求路径以<code>/api</code>开头的请求代理到<code>http://example.com</code>。<code>changeOrigin</code>选项用于控制是否改变源，设置为<code>true</code>表示改变，<code>pathRewrite</code>用于路径重写，这里将<code>/api</code>去掉。</p><p><strong>React框架：</strong></p><blockquote><p>以下内容来自chatGPT:</p></blockquote><p>在 <code>package.json</code> 文件中添加一个 <code>proxy</code> 字段，指定代理的目标地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;your-react-app&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;proxy&quot;: &quot;http://example.com&quot;, // 代理目标地址</span><br><span class="line">  // 其他配置...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你需要更多的配置选项，可以创建一个 <code>setupProxy.js</code> 文件在项目根目录下（确保没有其他同名文件）。在这个文件中，你可以使用 <code>http-proxy-middleware</code> 库来进行更复杂的代理配置。首先，安装该库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install http-proxy-middleware --save</span><br></pre></td></tr></table></figure><p>创建 <code>setupProxy.js</code> 文件，并添加代理配置，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const &#123; createProxyMiddleware &#125; = require(&#x27;http-proxy-middleware&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = function(app) &#123;</span><br><span class="line">  app.use(</span><br><span class="line">    &#x27;/api&#x27;, // 请求路径以 /api 开头的将被代理</span><br><span class="line">    createProxyMiddleware(&#123;</span><br><span class="line">      target: &#x27;http://example.com&#x27;, // 代理目标地址</span><br><span class="line">      changeOrigin: true,</span><br><span class="line">      pathRewrite: &#123;</span><br><span class="line">        &#x27;^/api&#x27;: &#x27;&#x27;, // 路径重写</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述配置中，请求路径以 <code>/api</code> 开头的请求将被代理到 <code>http://example.com</code>，同时进行了一些配置，例如 <code>changeOrigin</code> 用于改变源，<code>pathRewrite</code> 用于路径重写。</p><p><strong>Nginx代理：</strong></p><blockquote><p>Nginx是一种高性能的开源Web服务器，同时也可以用作反向代理服务器。</p></blockquote><p>反向代理：指代理服务器接收客户端的请求，然后将请求转发给内部服务器，最后将内部服务器的响应返回给客户端。</p><p>通过nginx反向代理可以解决跨域问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name local.test;</span><br><span class="line">        location /api &#123;</span><br><span class="line">            proxy_pass http://localhost:8080;</span><br><span class="line">        &#125;</span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass http://localhost:8000;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码解释如下：</p><ol><li><code>listen 80;</code>: 监听80端口，这是HTTP的默认端口。</li><li><code>server_name local.test;</code>: 配置Nginx监听的域名，这里是 <code>local.test</code>。当有请求到达这个域名时，Nginx将根据后续的 <code>location</code> 配置来处理请求。</li><li><code>location /api &#123; proxy_pass http://localhost:8080; &#125;</code>: 当请求的路径是 <code>/api</code> 时，Nginx会将请求代理到 <code>http://localhost:8080</code>，即将这个请求转发到本地的8080端口。</li><li><code>location / &#123; proxy_pass http://localhost:8000; &#125;</code>: 对于其他路径，Nginx会将请求代理到 <code>http://localhost:8000</code>，即将这个请求转发到本地的8000端口。</li></ol><p>在后端接口路径前面加上”/api”，前端调用该接口时，发送请求的域名和端口和浏览器一致，请求会由nginx进行代理转发到后端，就解决了跨域问题。</p><h3 id="服务器告诉浏览器允许跨域："><a href="#服务器告诉浏览器允许跨域：" class="headerlink" title="服务器告诉浏览器允许跨域："></a>服务器告诉浏览器允许跨域：</h3><p>这种方式的原理就是CORS技术（<strong>跨源资源共享</strong>），可以参考这篇文章：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">跨源资源共享（CORS） - HTTP | MDN (mozilla.org)</a></p><blockquote><p>CORS一种基于 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP">HTTP</a> 头的机制，该机制通过允许服务器标示除了它自己以外的其他<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Origin">源</a>（域、协议或端口），使得浏览器允许这些源访问加载自己的资源。</p></blockquote><p>前面说的”预检”也是该技术的一个机制。这个允许服务器除了它自己以外的其他源加载资源的标识就是：”Access-Control-Allow-Origin” ，也就是说给跨域请求加上”Access-Control-Allow-Origin”并设置允许的源即可解决跨域问题。</p><h4 id="Springboot项目解决跨域问题的方式："><a href="#Springboot项目解决跨域问题的方式：" class="headerlink" title="Springboot项目解决跨域问题的方式："></a>Springboot项目解决跨域问题的方式：</h4><p>参考文章：<a href="https://juejin.cn/post/7229139006080253989">SpringBoot 项目解决跨域的几种方案 - 掘金 (juejin.cn)</a></p><h5 id="1-SpringBoot-配置-CORS-解决跨域："><a href="#1-SpringBoot-配置-CORS-解决跨域：" class="headerlink" title="1. SpringBoot 配置 CORS 解决跨域："></a>1. SpringBoot 配置 CORS 解决跨域：</h5><ol><li>在项目中创建一个新的配置文件</li><li>添加<code>@Configuration</code>注解实现<code>WebMvcConfigurer</code>接口</li><li>重写<code>addCorsMappings</code>方法并设置允许跨域的代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>) <span class="comment">// 所有接口</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>) <span class="comment">// 是否发送 Cookie</span></span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>) <span class="comment">// 支持域</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>) <span class="comment">// 支持方法</span></span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .exposedHeaders(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-SpringBoot-通过-CorsFilter-解决跨域"><a href="#2-SpringBoot-通过-CorsFilter-解决跨域" class="headerlink" title="2. SpringBoot 通过 CorsFilter 解决跨域:"></a>2. SpringBoot 通过 CorsFilter 解决跨域:</h5><p>和上面的方法原理相同，上面方法是通过配置类来实现CORS的，这种方式是通过拦截器来实现CORS的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCorsFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建 CORS 配置对象</span></span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        <span class="comment">// 支持域</span></span><br><span class="line">        config.addAllowedOriginPattern(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 是否发送 Cookie</span></span><br><span class="line">        config.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">// 支持请求方式</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 允许的原始请求头部信息</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 暴露的头部信息</span></span><br><span class="line">        config.addExposedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.添加地址映射</span></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">corsConfigurationSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        corsConfigurationSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line">        <span class="comment">// 3.返回 CorsFilter 对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(corsConfigurationSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-使用-CrossOrigin注解解决跨域："><a href="#3-使用-CrossOrigin注解解决跨域：" class="headerlink" title="3. 使用@CrossOrigin注解解决跨域："></a>3. 使用<strong>@CrossOrigin</strong>注解解决跨域：</h5><p>可以在我们的控制器类或控制器方法上添加，添加在类上表示里面所有方法都可跨域，添加在方法上表示指定方法可以跨域。</p><p>@CrossOrigin中有2个参数：</p><ul><li><strong>origins</strong>： 允许可访问的域列表</li><li><strong>maxAge</strong>:准备响应前的缓存持续的最大时间（以秒为单位）。</li></ul><p>下面是最简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="meta">@CrossOrigin</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;成功&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用Nginx解决跨域："><a href="#使用Nginx解决跨域：" class="headerlink" title="使用Nginx解决跨域："></a>使用Nginx解决跨域：</h4><p>上面提到用nginx反向代理解决跨域，在nginx服务器进行代理时，也可以为请求加上 ‘Access-Control-Allow-Origin’ 响应头。只不过网上的配置有一点坑，很难找到适合的，鱼皮老哥当时解决了很久，这里直接贴鱼皮老哥的配置了：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span><span class="regexp"> ^~</span> /api/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:8080/api/;</span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="variable">$http_origin</span>;</span><br><span class="line">    <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Methods <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Headers <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$request_method</span> = <span class="string">&#x27;OPTIONS&#x27;</span>) &#123;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span> <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="variable">$http_origin</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Methods&#x27;</span> <span class="string">&#x27;GET, POST, OPTIONS&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Headers&#x27;</span> <span class="string">&#x27;DNT,User-Agent,x-Requested-With,If-Modified-Since,Cache-Control,content-Type,Range&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Max-Age&#x27;</span> <span class="number">1728000</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Content-Type&#x27;</span> <span class="string">&#x27;text/plain; charset=utf-8&#x27;</span>;</span><br><span class="line">        <span class="attribute">add_header</span> <span class="string">&#x27;Content-Length&#x27;</span> <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">204</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该块指定此配置适用于 URI 路径以 开头的请求。<code>location ^~ /api/``/api/</code></li><li><code>proxy_pass http://127.0.0.1:8080/api/;</code>用于将请求转发到指定的后端服务器（在本例中为）。<code>http://127.0.0.1:8080/api/</code></li><li><code>add_header &#39;Access-Control-Allow-Origin&#39; $http_origin;</code>将“Access-Control-Allow-Origin”标头设置为传入请求中的“Origin”标头的值，从而允许跨源请求。</li><li><code>add_header &#39;Access-Control-Allow-Credentials&#39; &#39;true&#39;;</code>指示凭据（如 cookie 和 HTTP 身份验证）应包含在跨域请求中。</li><li><code>add_header Access-Control-Allow-Methods &#39;GET, POST, OPTIONS&#39;;</code>指定跨域请求中允许的 HTTP 方法。</li><li><code>add_header Access-Control-Allow-Headers &#39;*&#39;;</code>允许跨域请求中的任何标头。</li><li>该块处理预检 OPTIONS 请求。它为 CORS 预检响应设置必要的标头，指示允许的方法、标头和其他与 CORS 相关的设置。<code>if ($request_method = &#39;OPTIONS&#39;)</code></li></ul><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>解决跨域问题有两大思路：1.将域名和端口修改一致；2.让服务器告诉浏览器，允许跨域，也就是返回”Access-Control-Allow-Origin”响应头。思路一可以手动改路径也可以使用代理转发请求，一般前端框架会自带代理，也可以使用nginx反向代理实现；思路二在springboot项目中可以定义配置类或者拦截器配置来设置请求头，也可以使用@CrossOrigin注解解决跨域，最后也可以使用nginx配置请求头解决跨域问题。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>本文参考了以下文章并引用了部分内容，如有侵权，请联系本人（abin0926@qq.com）删除。</p><p><a href="https://juejin.cn/post/7229139006080253989">SpringBoot 项目解决跨域的几种方案 - 掘金 (juejin.cn)</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS">跨源资源共享（CORS） - HTTP | MDN (mozilla.org)</a></p><p><a href="https://zhuanlan.zhihu.com/p/132534931">10 种跨域解决方案（附终极方案） - 知乎 (zhihu.com)</a></p><p>也参考了鱼皮老哥的视频内容，但是是星球内部视频，这里给老哥打个广告吧，以示感谢：</p><p><a href="https://www.code-nav.cn/">主页 - 编程导航 (code-nav.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我想逃离这片原本温暖的港湾</title>
      <link href="/2024/01/22/think-2/"/>
      <url>/2024/01/22/think-2/</url>
      
        <content type="html"><![CDATA[<p>不知道从什么时候开始，家变得不再温馨，家人的各种询问、催促、不理解甚至让人想要逃离。什么时候开始变得呢？我开始回忆：</p><p>我家在一个算不上很偏远的农村，周围是黑压压的大山，似乎村里的人永远也走不出去。父母拼尽大半辈子的力气在村里修了一座楼房，事实证明，这座房子确实花光他们的精力与积蓄，以至于到现在十年了还是毛胚房，内部没有一点装修。小时候受课本和教育影响，觉得当个农民在农村自给自足也还不错。</p><p>可是啊，“谁让我读了那么多的书，知道了双水村以外还有个更大的世界”，看过了外面世界的繁华，也渐渐懂得了现实的残酷，我明白了我呆着的农村就是落后与穷。村里的人似乎在我家房子修好两三年里也都明白了这个道理，纷纷搬进了城里，有人做起了小生意，也有人依然在外打工养着城里那套房子，不过现在看，他们似乎过得都还不错。父母开始懊恼当初的抉择，可是也于事无补，于是寄希望于我，希望带他们走出这层层的大山。</p><p>我也渐渐明白了自己肩上的责任，我也以带父母走出大山作为自己的目标，我以为考上了大学就会离这个目标越来越近，却越来越发现这个目标离我遥不可及。我看到了经济的下滑，我看到了上涨的房价，我看到了工作的难找，我也看到了挣钱的不易…我想着自己未来的生活，自己的一车一房就已经需要用大半辈子去努力了，又何谈带父母走出大山呢？</p><p>看着逐渐衰老的父母，他们的头发已经花白，身子也已经不在笔直，视力和听力也大不如从前。我想他们也打不了几年的工了，我得为他们想想后路，但是我也确实想不到他们除了打工还能干什么。思来想去，劝他们去考个驾照，就算以后不拉客，出门也方便，可是他们说自己老了考不动了，可是明明他们也才五十多岁啊！终于在我坚持劝了一年后，父亲决定先试试，于是下载了驾考宝典，每天晚上看看，可是一年过去了，最高分也只有八十分，父亲也几度想放弃。</p><p>我也有一些动摇了，可是每次回家时，我要苦等几个小时的顺风车，等不等得到还得看运气；回到家想去县城办点事，又得等很久的车；想去找好朋友玩可是没有直接的交通工具所以放弃…这些时候我就会想如果家里有辆车多好，又想到老父亲的状态，心里只是深深的无力感。</p><p>秋招中摸爬滚打了几个月，终于找到一份月薪一万的工作，父母很开心，觉得我的工作稳定了，可是只有我知道这个全网无好评的外包公司，试用期六个月的风险有多大。于是我想春招继续找，我把想法告诉了父母，当我说出违约金五千，他们沉默了很久，然后告诉我：一个月一万已经很不错了。我当然明白他们的意思，他们不希望，可是我不理解，为什么我诠释了那么久的利弊，他们到最后也只关心月薪和违约金呢？</p><p>想不到之前觉得遥远甚至荒诞的催婚居然降临到了我这个校门都没踏出的小伙子身上，我也不清楚爷爷为什么突然这么着急，但是我清楚现在的我等于没车没房没存款没工作，怎么可能有女孩子愿意跟我谈婚论嫁？更有点难过的是，我到现在都没谈过几段正经的恋爱。不过，“两袖清风怎敢误佳人”？</p><p>我是有点自卑的，可能是经历了这件事之后开始的：几年前我的姐姐和她谈了四年的男朋友准备订婚了，他的男朋友是浙江人，在到日子的前一天，男方的父母刚走到我们县城，甚至都没到我们村里，就因为受不了这边的落后直接反悔回家了，那是四年的感情啊。我害怕了，我怕多年的感情会被家庭条件打破，之前有谈过一段恋爱，在家我甚至不敢开视频，因为我怕家里的毛胚墙面会吓到女孩子。当时我将恋爱的消息告诉了父母，父母很高兴说要给我涨生活费，于是我从一个月一千五百块的生活费涨到了一个月一千六百块，因为是异地，这点生活费甚至不够我去见她一面，见不了面的感情真的挺难维系的，于是这段感情也无疾而终了。</p><p>我该怎么将这些事告诉爷爷呢？就算告诉他又有什么用呢？除了加深他的愧疚感外没有其他任何意义，于是我只能在他的催促下说到：您先别急，我会加紧找的。</p><p>我总感觉父母闲不下来，而且他们也不想让我闲下来，总会找些莫名其妙的事情让我做，有时候他们两个人可以轻松做完的事非要给我分一些做，可是卧也不是没事做啊，我决定春招再找找工作，现在正在完善两个项目，可是他们不懂啊，我说我有事，他们会觉得这是借口。</p><p>我终于想明白了，原来是因为我成年了，当一个人成年后，家就不再是温暖的港湾了，而是一种不得不承担的责任，压得我好想逃，逃离这片不再温暖的港湾。</p>]]></content>
      
      
      <categories>
          
          <category> 胡思乱想 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>爱上小树枝</title>
      <link href="/2024/01/16/story-1/"/>
      <url>/2024/01/16/story-1/</url>
      
        <content type="html"><![CDATA[<p>从前，在一块刚刚荒废的田里，有一根小小的嫩芽冒出了头，很小很小，似乎一阵风就可以将她吹走，她浑身碧绿，像一块刚被细细打磨过的翡翠。她的周围有几棵稍微强壮的树苗，每当风雨到来，她可以躲在树苗下，他们也愿意为她遮风挡雨，看得出来，他们很照顾她。</p><p>不远但又很远的地方，有一个不大不小的石块。他的周围光秃秃的，他很无聊也很孤独，他每天唯一的乐趣就是看着这块地里一个又一个嫩芽冒出头，然后慢慢长高。所以，那天小嫩芽刚冒头，小石块就注意到了她，“哇，又多了一颗芽”“奇怪，她怎么能这么绿呢？”“这个小芽还挺好看的”，小石块想着。</p><p>小石块做了一个梦，梦见那棵小嫩芽挥舞着她仅有的一片叶子，冲他喊：“喂！过来玩！”，他睁开眼，发现那好像不是梦，那棵嫩芽冲他挥舞着她的叶子，喊到：“喂！那块憨憨的石头，你能过来吗？”小石块有点懵，他认为自己永远不会被注意到，他很开心，他努力的想向小嫩芽那边挪动一点，但是他做不到。</p><p>“我做不到，我移动不了，”小石块失望的回答，“但是再被太阳晒一段时间，风就会带着很多我分出的小碎渣过来。”</p><p>“我知道，你的那些碎渣最后会变成我们的肥料呢，谢谢你呀”，小嫩芽继续说，“看你孤零零的，我们做朋友吧。”</p><p>“好啊好啊，等我再小点，就能被风带着慢慢向你那边挪动，但是会很慢很慢。”</p><p>“小问题啦，慢慢来，能前进就行，我等你啊。”</p><p>从那以后，小石块再不关心有没有新芽长出来，也不再关注其他树苗长了多高，他的心里只有快点被风化，让自己可以早点去到小嫩芽身边。</p><p>小石块珍惜着每一次暴晒，每一次刮风，每一场大雨。太阳的炙烤让他表面变得酥脆，大风的袭挂带走他表面没法附着的表皮，雨水的冲刷让剩下的那些顽固颗粒掉落，过程让小石块很痛苦，但是小石块心里是开心的，尤其是看着自己风化的小颗粒被风带到小嫩芽根部的时候，小嫩芽也会挥舞着越来越多的叶子，摇曳着身子向小石头致谢。</p><p>终于，小石块变得足够小，每次吹往小嫩芽那边的大风可以将她挪动一点点，看着自己离小嫩芽越来越近，小石块很开心，小嫩芽也会为他加油。</p><p>那天的风特别大，可是那风却是逆着小石块前进的方向吹的，小石块被吹了回去，甚至比他开始距离小嫩芽的距离更远。小石块绝望了，那几根树苗也开始对小石块冷嘲热讽，小嫩芽也有些伤心，但是她还是鼓励小石块继续努力。</p><p>小石块重新开始了他的行程，这次他前进一点就努力将自己嵌入土中，等待下一次朝向小嫩芽的风吹来，再将自己展露出来。<br>一天一天，小嫩芽也渐渐长成了小树苗，她浑身依然碧绿，小石块离小树苗的距离也越来越近。</p><p>一场暴雨圆了小石块的梦，雨水将小石块前面的一点地冲陷，小石块也顺势向下滚去。暴雨停止，小石块已经到了小树苗的身边。<br>小树苗很开心，小石块更开心。他们每天能从早上聊到晚上，小石块也会趁着每次下雨将自己的表面的腐渣送向小树苗，给小树苗当肥料。</p><p>一天，小树苗问小石块，“你知道这块田外面是什么样子吗？”，小石块回答：“不知道啊，我一出生就在这田里，我也不在乎外面的世界怎样，在你身边就够了。”小石块自以为自己的回答很不错，小树苗却是眉头一皱，小声说道：“可是我很想看看外面的世界。”小石头立马改口说：“那未来有机会我们一起去看看！”虽然小树苗和小石块都知道这不可能实现，但是小树苗还是高兴的回答说：“等我长了枝，你到我身上来，我带你看外面的世界！”</p><p>日子一天一天过去，小树苗成了众多小树枝中的一枝，越来越高，小石块在每日的风化下成了小石子，他们每天的生活似乎没有变化，但是小石子没有注意到的是，他们的距离随着小树枝的变高再慢慢变远，小树枝周围的树苗也渐渐对小石子有了不满，认为他抢走了他们的小树枝。</p><p>一天，一个小男孩来到了田里，他们拨弄着小树枝周围的树苗，其中一根树苗借着男孩的拨弄将小石子弹开，小石子大喊：“哦不！”更不幸的是，小男孩将小石子捡起，然后当做飞镖扔了出去，小石子绝望的看向小树枝，小树枝有点悲伤但是小石子能感受到，小树枝这次的情绪波动甚至没有那次自己被大风吹走时大，不幸中的万幸，小男孩的力气不算大，小石子没有被扔出这片田里。<br>小石子对着小树枝大喊：“等我！我会再次去到你身边的。”小树枝却是摇了摇头，说道：“不要再折磨你自己了，你应该有你自己的生活。”小石子呆住了，他难过，绝望，悔恨…</p><p>小石子一夜未眠，第二天早上，小树枝的一片叶子被风带了过来，上面写着：小石子，谢谢你。和你在一起的时光很快乐，我知道你对我很好，我也相信你有能力再次回来，但是或许我们从一开始就不是一路人。我真的很想去看看这片天地外的世界，我需要努力长高，可是你没有办法跟随我一起，我也不希望你以我的目标为目标，你应该有自己的生活，我也不想你再未来回来而受尽折磨。对不起，耽误了你那么长时间，愿安。</p><p>小石子怔怔地望着小树枝，树枝随风招摇 依然美好…</p>]]></content>
      
      
      <categories>
          
          <category> 故事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爱上小树枝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总有些美好值得奔赴</title>
      <link href="/2023/10/05/trip-3/"/>
      <url>/2023/10/05/trip-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>其实世界上美好的东西不太多的，我知道两个，立秋傍晚从河对岸吹来的风，和二十来岁笑起来要命的你。</p></blockquote><h2 id="奔赴-风都是甜的"><a href="#奔赴-风都是甜的" class="headerlink" title="奔赴 - 风都是甜的"></a>奔赴 - 风都是甜的</h2><p>一个电话，一时冲动，一场山海。奔赴美好的途中风都是甜的。不过去除滤镜有一说一，到上海的火车是我坐过最舒适的火车，座位和桌板很干净，一点不像其他火车那样脏乱。十点左右整个车厢就没有一点声音了，也没有了推销车和售卖车，堪比静音车厢，对比上次到重庆的火车简直一个天上一个地下。更幸运的是，我的座位靠窗，我可以靠着车壁，舒适度又提升了一个档次。</p><p>有点失落的是，并没有像偶像剧一样一下火车期待的人就出现。不过我的酒店和她住的地方都在张江那边，距离市区确实有距离。</p><h2 id="相见-慌乱"><a href="#相见-慌乱" class="headerlink" title="相见 - 慌乱"></a>相见 - 慌乱</h2><p>事实证明，我还是可以在人群中一眼认出她，即使隔着一个路口。我想过无数种和她见面的场景，我想我要落落大方，谈笑有度。可是她真正出现在我面前时，我还是慌了神，想好的说辞一句也说不出口，只能笑笑，举起给她的奶茶和礼物。很巧，我的礼物盒子和她穿的衣服都是好看的浅绿色。</p><p>有点尴尬，我本身不善言辞，她似乎为了配合我说话也很小声，地铁上，我们简单交流了两句，她就玩起了手机，我看着她想找点话题，却又不知道说些什么。</p><h2 id="东方明珠-迟钝"><a href="#东方明珠-迟钝" class="headerlink" title="东方明珠 - 迟钝"></a>东方明珠 - 迟钝</h2><p>到上海当然要看东方明珠了，近距离没开灯的东方明珠真的好丑。人很多，没想到她居然主动挽起了我的胳膊，错愕过后她就松开了，似乎也只是防止任人群冲散我俩，我TM真是迟钝！</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122663788901.jpg" alt="13352122663788901"></p><h2 id="陆家嘴三件套-担心"><a href="#陆家嘴三件套-担心" class="headerlink" title="陆家嘴三件套 - 担心"></a>陆家嘴三件套 - 担心</h2><p>下了桥，开始寻找陆家嘴三件套的最佳取景地，路上她说你可怎么办哟，都要工作的人了还这么内向。不开灯的陆家嘴三件套也好丑。还好刚要走的时候开灯了，可惜拍的不好看。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122962756020.jpeg" alt="13352122962756020"></p><h2 id="轮渡-拍景-or-拍人？"><a href="#轮渡-拍景-or-拍人？" class="headerlink" title="轮渡 - 拍景 or 拍人？"></a>轮渡 - 拍景 or 拍人？</h2><p>摆出拍景的样子，实际只为了拍你。轮渡人很多，上层是上不去了，还好勉强挤了个窗边的位置，她似乎有心事。风吹着有点凉。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240215121841.jpg" alt="微信图片_20240215121841"></p><h2 id="外滩-人从众仌仌"><a href="#外滩-人从众仌仌" class="headerlink" title="外滩 - 人从众仌仌"></a>外滩 - 人从众仌仌</h2><p>外滩人真的巨多，我想牵起她的手，却总是胆怯，将准备伸出去的手缩了回来。全称几乎被人群推着走，终于到了一处人少的地方，趴在围栏上，看着陆家嘴，一艘大邮轮经过，她说，等她有钱了一定要去坐坐那大邮轮。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240213180218.jpg" alt="微信图片_20240213180218"></p><h2 id="乍浦路桥-唯一的合照"><a href="#乍浦路桥-唯一的合照" class="headerlink" title="乍浦路桥 - 唯一的合照"></a>乍浦路桥 - 唯一的合照</h2><p>她说她想去乍浦路桥，果然她的眼光不错，这个桥可以拍到东方明珠的全貌。也是在这座桥上，我有了第一张也是唯一一张我们的合照。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122952749400.jpeg" alt="13352122952749400"></p><h2 id="上海邮政博物馆-路过"><a href="#上海邮政博物馆-路过" class="headerlink" title="上海邮政博物馆 - 路过"></a>上海邮政博物馆 - 路过</h2><p>过了乍浦路桥，寻找地铁口的路上经过了上海邮政博物馆，她说可惜没买票，不然这个博物馆还值得一逛。其实我的想法是：只要有你，哪都值得。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122927188698.jpeg" alt="13352122927188698"></p><h2 id="第一顿晚餐-尴尬"><a href="#第一顿晚餐-尴尬" class="headerlink" title="第一顿晚餐 - 尴尬"></a>第一顿晚餐 - 尴尬</h2><p>她挑选了一家大排档。第一次和她面对面坐着吃饭，有点紧张，也有点尴尬，她说：你要不说话我就玩手机了，我脑子一抽说了之前高中有个同学跳楼了。现在想想MD我也该跳下去。不过她选的地方饭菜味道真不错。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122919748457.jpeg" alt="13352122919748457"></p><h2 id="再见-好巧"><a href="#再见-好巧" class="headerlink" title="再见 - 好巧"></a>再见 - 好巧</h2><p>本来想着给她带杯奶茶，可惜有点早，奶茶店都还没开门，于是在路上的便利店买了水溶，记得她喜欢酸橘子味的，可惜刚好没有这个味道，于是我买了我比较喜欢的西柚味。很巧，她也买了两瓶酸橘子味的水溶。我和他解释没有酸橘子味的了，她说你不用解释的。</p><h2 id="复兴公园-玫瑰"><a href="#复兴公园-玫瑰" class="headerlink" title="复兴公园 - 玫瑰"></a>复兴公园 - 玫瑰</h2><p>在去思南公馆的路上，路过了一个公园，她说进去转转，她说她好想快点步入老年生活啊。玫瑰园里的玫瑰开着，分不清是玫瑰还是月季。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240214113612.jpg" alt="微信图片_20240214113612"></p><h2 id="思南公馆-没什么特别"><a href="#思南公馆-没什么特别" class="headerlink" title="思南公馆 - 没什么特别"></a>思南公馆 - 没什么特别</h2><p>其实就是民国小洋楼，在上海其实并不少见，个人觉得没什么看头。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240214165327.jpg" alt="微信图片_20240214165327"></p><h2 id="古董花园-很小"><a href="#古董花园-很小" class="headerlink" title="古董花园 - 很小"></a>古董花园 - 很小</h2><p>走着正念叨古董花园在哪怎么没看见，她指着对面说，那不就是，我一瞅，好家伙，真的小啊，感觉就一间房一样，她问我要不要进去，我连忙摇头，太小了。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122819290958.jpeg" alt="13352122819290958"></p><p>倒是古董花园旁边的房子被她拍的挺好看的。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122829125529.jpeg" alt="13352122829125529"></p><h2 id="沿途的风景-意境"><a href="#沿途的风景-意境" class="headerlink" title="沿途的风景 - 意境"></a>沿途的风景 - 意境</h2><p>往前走，我看见了一面涂鸦墙，亏我还比划了半天，结果发现还是她拍的好看，蛮有意境。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240214170220692.png" alt="image-20240214170220692"></p><h2 id="武康大楼-突兀"><a href="#武康大楼-突兀" class="headerlink" title="武康大楼 - 突兀"></a>武康大楼 - 突兀</h2><p>一座比较突兀的红砖房，拍照的人很多！！</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122901038912.jpeg" alt="13352122901038912"></p><h2 id="徐家汇教堂-粉色"><a href="#徐家汇教堂-粉色" class="headerlink" title="徐家汇教堂 - 粉色"></a>徐家汇教堂 - 粉色</h2><p>这个教堂挺好看的，下面这粉黛子花也增添了一点浪漫。当然也有点其他的原因。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122910420166.jpeg" alt="13352122910420166"></p><h2 id="徐家汇书院-懊恼"><a href="#徐家汇书院-懊恼" class="headerlink" title="徐家汇书院 - 懊恼"></a>徐家汇书院 - 懊恼</h2><p>书院蛮大的，比钟书阁大一些，也有很多人在认真的读书，我们到了围栏处，我说有座位要不要坐会儿，她说不用。她趴在围栏上看着与在远处，不知道在想些什么，我看着她，也不知道在想些什么。下楼时到了一个转角，她让我给她拍张照，我正准备拍，她突然招呼我说走了，我问为什么，她说：从上面拍你想把我拍的多矮呀，我懊恼，我说我站下面重新给你拍一张，她说不用了。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122796476187.jpeg" alt="13352122796476187"></p><h2 id="蓝梗脱口秀-有烂梗"><a href="#蓝梗脱口秀-有烂梗" class="headerlink" title="蓝梗脱口秀 - 有烂梗"></a>蓝梗脱口秀 - 有烂梗</h2><p>小剧场还不错，主持人也不错。演员怎么说呢？五个演员，两个60分左右，一个40分，一个80分，一个90分。90分的张三全程爆梗，算是救场吧。据说，人在欢笑的时候会不自觉的看向自己喜欢的人，我看向她，她笑得很开心，不知道她有没有看向过我。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122699505947.jpg" alt="13352122699505947"></p><h2 id="破店小酒馆-辣"><a href="#破店小酒馆-辣" class="headerlink" title="破店小酒馆 - 辣"></a>破店小酒馆 - 辣</h2><p>看完脱口秀，她选了一家川菜馆。味道很不错，虽然特别辣，但是我还是忍不住去吃。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122786502704.jpeg" alt="13352122786502704"></p><h2 id="静安寺-来过看过"><a href="#静安寺-来过看过" class="headerlink" title="静安寺 - 来过看过"></a>静安寺 - 来过看过</h2><p>她说其实静安寺里面没有什么看头，刚好我也不喜欢逛寺庙，何况还要圆子，拍张照走人，主打来过看过。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122678242512.jpg" alt="13352122678242512"></p><h2 id="人民广场-喷泉"><a href="#人民广场-喷泉" class="headerlink" title="人民广场 - 喷泉"></a>人民广场 - 喷泉</h2><p>本来想去城隍庙的，但是没赶上，就准备带她去打会台球，于是到了人民广场，随手拍了两张。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122878332747.jpeg" alt="13352122878332747"></p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122763255236.jpeg" alt="13352122763255236"></p><h2 id="风云再起台球-有年代了"><a href="#风云再起台球-有年代了" class="headerlink" title="风云再起台球 - 有年代了"></a>风云再起台球 - 有年代了</h2><p>在人民广场的商城里的一个角落，面积还算大，但是台子真的感觉有年代了，挑选的位置也不是很好，靠墙那边伸不开手。有点小贵，不太值。她是第一次玩台球，我本来以为她会不感兴趣，但是她好像玩的还挺开心。结账时老板娘问道：专门带女朋友过来玩的？我笑笑没说话。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240215114219.jpg" alt="微信图片_20240215114219"></p><h2 id="送花-懵"><a href="#送花-懵" class="headerlink" title="送花 - 懵"></a>送花 - 懵</h2><p>“男生送花最有意义的原因在于，他要经历捧着花走在路上时，路人的眼光，这种感觉大概就是，我捧着花在去见你的路上，路人都回头看我，和我手捧着的鲜花，有老人，有白领，有小孩，但我却记不清他们的模样，我只记得你快到了，我就快要见到你了，见到我想见的你，时间越来越近，我就越来越欢喜。”</p><p>手捧着鲜花，穿过2公里的街道，原来我也没那么在意他人的眼光。当我把花递给她时，她有点懵，但是她捧着鲜花的样子真的好美。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240215115752.jpg" alt="微信图片_20240215115752"></p><h2 id="豫园-不值"><a href="#豫园-不值" class="headerlink" title="豫园 - 不值"></a>豫园 - 不值</h2><p>普通园林，不是很大，要40圆子门票，不是很值，不如苏州的那些园林。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122857330851.jpeg" alt="13352122857330851"></p><h2 id="城隍庙-普通商业街"><a href="#城隍庙-普通商业街" class="headerlink" title="城隍庙 - 普通商业街"></a>城隍庙 - 普通商业街</h2><p>紧挨着豫园，和其他商业街一样，各种商家店铺。<img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13352122774524327.jpeg" alt="13352122774524327"></p><h2 id="笑乐汇-郭德纲弟子创办"><a href="#笑乐汇-郭德纲弟子创办" class="headerlink" title="笑乐汇 - 郭德纲弟子创办"></a>笑乐汇 - 郭德纲弟子创办</h2><p>郭德纲弟子高鹤彩创办，整体还可以，8、9分的样子，但是说实话，我觉得最好笑的不是高鹤彩的相声，是前面他弟子的。</p><p>位置不太好找，我们围着那楼转了两圈，才找到大门。到的还是有点早了，她说：你要是不说点什么我就玩手机了，我也不知道说点什么，于是她玩手机，我看着她。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20240215122337.jpg" alt="微信图片_20240215122337"></p><h2 id="酸菜鱼-紧张"><a href="#酸菜鱼-紧张" class="headerlink" title="酸菜鱼 - 紧张"></a>酸菜鱼 - 紧张</h2><p>在商场的一个角落，味道还不错。</p><p>在桌上，她问我：你是不知道说些什么还是不知道从哪说起？我也不知道，她说：昨天打台球的时候你状态就很好啊。我低头巴拉着碗里的鱼皮。</p><p>她点了两杯霸王茶姬，我居然紧张到用平的那头去插。</p><p>她说：你再不说点什么你就要走了。终于我问起了她的工作，慢慢的聊了起来，气氛稍微缓和。</p><h2 id="谈小娱自助台球-环境不错"><a href="#谈小娱自助台球-环境不错" class="headerlink" title="谈小娱自助台球 - 环境不错"></a>谈小娱自助台球 - 环境不错</h2><p>场地很大，台子很新，比起昨晚那家环境好了几倍，扫码自助的，也很便宜，值。</p><p>她进步还是很快的，今天就能稳稳击球了。</p><p>时间过得很快，离开时，我说咱俩再合一张，她说不要，我有点失落。</p><h2 id="地铁-下次见面，勇敢一些"><a href="#地铁-下次见面，勇敢一些" class="headerlink" title="地铁 - 下次见面，勇敢一些"></a>地铁 - 下次见面，勇敢一些</h2><p>美好的时光总是飞快，终于还是到了分别的时刻。</p><p>地铁上，她说：我马上到站了，你有什么想说的吗？我看着她，很想抱抱她，在她身边的手动了动，终究没敢伸出去。我想了想说：以后骑车别看手机，单手骑车很危险。她说：你就想说这？我都习惯了。</p><p>在她到站的前一分钟，她告诉我：希望下次见面时，你可以勇敢一些。</p><p>我望着她远去的身影，脑子有点乱。</p><h2 id="离开-该改变了"><a href="#离开-该改变了" class="headerlink" title="离开 - 该改变了"></a>离开 - 该改变了</h2><p>上海的火车居然提前30分钟检票，刚进站没一会就坐上了火车，返程的火车就不像来时那么整洁了，位置也不好，靠过道，最难受的是，对面那姨有狐臭！很难受。</p><p>坐在车上，回想着这几天的一幕幕，像梦一样，很美好，但似乎因为我的沉默寡言过程并不那么愉快。又想起了那一句“希望下次见面时，你能勇敢一点。”我从来没有像现在那么想改变，我也真的该改变了。</p><p>下次见面时，一定要勇敢一点。</p>]]></content>
      
      
      <categories>
          
          <category> 旅游日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
            <tag> 上海 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot集成log4j，并基于disruptor实现异步日志</title>
      <link href="/2023/08/16/study-3/"/>
      <url>/2023/08/16/study-3/</url>
      
        <content type="html"><![CDATA[<p>Java日志框架挺多的，log4j、slf4j、logback…logback与log4j的作者是同一个人，而logback实际上是log4j的改进版，SpringBoot内置了logback，而logback天然又支持slf4，所以我们在使用Springboot开发时，可能不知不觉就使用了logback+slf4j的框架，这两个框架不需要另外去集成，所以这篇文章就讲讲springboot集成log4j。</p><h2 id="Springboot集成log4j："><a href="#Springboot集成log4j：" class="headerlink" title="Springboot集成log4j："></a>Springboot集成log4j：</h2><p>还是那“三板斧”：引依赖，写自定义配置，写配置文件。</p><h3 id="1-引依赖："><a href="#1-引依赖：" class="headerlink" title="1. 引依赖："></a>1. 引依赖：</h3><p>在springboot项目中先引入下面这个依赖，这里先埋个坑，后面再说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.1</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-log4j-spring-xml里自定义配置："><a href="#2-log4j-spring-xml里自定义配置：" class="headerlink" title="2. log4j-spring.xml里自定义配置："></a>2. log4j-spring.xml里自定义配置：</h3><p>其实文件名可以自己起，但是SpringBoot 官方推荐优先使用带有<code>-spring</code>的文件名作为你的日志配置，所以一般起名为：log4j-spring.xml，这些内容也可以在yml文件里配置，但是xml文件里内容也需要认识嘛，下面给一份比较完整的文件模板，复制就能使用那种，后续想自己配置功能修改即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">&quot;INFO&quot;</span> <span class="attr">monitorInterval</span>=<span class="string">&quot;5&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--变量配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 格式化输出：%date表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度 %msg：日志消息，%n是换行符--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- %logger&#123;36&#125; 表示 Logger 名字最长36个字符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOG_PATTERN&quot;</span> <span class="attr">value</span>=<span class="string">&quot;%date&#123;HH:mm:ss.SSS&#125; %X&#123;PFTID&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志存储的路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_PATH&quot;</span> <span class="attr">value</span>=<span class="string">&quot;../log&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;FILE_NAME&quot;</span> <span class="attr">value</span>=<span class="string">&quot;frame.log&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--https://logging.apache.org/log4j/2.x/manual/appenders.html--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--输出日志的格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制台只输出level及其以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，适合临时测试用--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">File</span> <span class="attr">name</span>=<span class="string">&quot;fileLog&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/temp.log&quot;</span> <span class="attr">append</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFileInfo&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/info.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-INFO-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 这个会打印出所有的warn及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFileWarn&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/warn.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-WARN-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;warn&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 这个会打印出所有的error及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;RollingFileError&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/error.log&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;FILE_PATH&#125;/$&#123;FILE_NAME&#125;-ERROR-%d&#123;yyyy-MM-dd&#125;_%i.log.gz&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> <span class="attr">onMatch</span>=<span class="string">&quot;ACCEPT&quot;</span> <span class="attr">onMismatch</span>=<span class="string">&quot;DENY&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;LOG_PATTERN&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--interval属性用来指定多久滚动一次，默认是1 hour--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span> <span class="attr">interval</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;10MB&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件开始覆盖--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;15&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--然后定义loggers，只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        &lt;logger name=&quot;org.mybatis&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            &lt;AppenderRef ref=&quot;Console&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        &lt;/logger&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--监控系统信息--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--若是additivity设为false，则子Logger只会在自己的appender里输出，而不会在父Logger的appender里输出。--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        &lt;Logger name=&quot;org.springframework&quot; level=&quot;info&quot; additivity=&quot;false&quot;&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            &lt;AppenderRef ref=&quot;Console&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--        &lt;/Logger&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--                &lt;AsyncLogger name=&quot;asyncLog&quot; level=&quot;info&quot; additivity=&quot;true&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;appender-ref ref=&quot;RollingFileInfo&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;appender-ref ref=&quot;Console&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;/AsyncLogger&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--                &lt;AsyncRoot level=&quot;info&quot; includeLocation=&quot;true&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;AppenderRef ref=&quot;RollingFileInfo&quot; /&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                    &lt;AppenderRef ref=&quot;Console&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;/AsyncRoot&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileInfo&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileWarn&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileError&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;fileLog&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这份文件里面注释解释的也比较清楚，很多配置在需要的时候将注释符去掉就可以了，这里就不去过多解释了，想具体了解的，可以去看看这篇文章：<a href="https://zhuanlan.zhihu.com/p/555185411">SpringBoot使用logback日志框架超详细教程 - 知乎 (zhihu.com)</a>虽然这篇文章讲的是logback框架，但是xml文件中的配置和log4j几乎一模一样，可以借鉴。</p><h3 id="3-在配置文件中指定-xml路径"><a href="#3-在配置文件中指定-xml路径" class="headerlink" title="3. 在配置文件中指定.xml路径:"></a>3. 在配置文件中指定.xml路径:</h3><p>写完xml文件，还需要在yml配置文件里指定一下log框架的配置文件路径，也就是xml文件路径，加上这一句就i行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  config: classpath:log4j-spring.xml</span><br></pre></td></tr></table></figure><h2 id="填前面的坑（解决依赖冲突方法）："><a href="#填前面的坑（解决依赖冲突方法）：" class="headerlink" title="填前面的坑（解决依赖冲突方法）："></a>填前面的坑（解决依赖冲突方法）：</h2><p>这时候启动项目，你会发现项目压根启动不了，报错啦哈哈，差不多会报下面的错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Class path contains multiple SLF4J providers.</span><br><span class="line">SLF4J: Found provider [ch.qos.logback.classic.spi.LogbackServiceProvider@4e41089d]</span><br><span class="line">SLF4J: Found provider [org.apache.logging.slf4j.SLF4JServiceProvider@32a068d1]</span><br><span class="line">SLF4J: See https://www.slf4j.org/codes.html#multiple_bindings for an explanation.</span><br><span class="line">SLF4J: Actual provider is of type [ch.qos.logback.classic.spi.LogbackServiceProvider@4e41089d]</span><br></pre></td></tr></table></figure><p>我在做项目时的报错信息和这个demo里的报错信息不太一样，但是看到”SLF4J”，解决方式都时一样的，出现报错的原因就是前面说过，springBoot内置了日志框架，实现了slf4j，slf4j与log4j冲突了：</p><p><img src="C:\Users\周斌\AppData\Roaming\Typora\typora-user-images\image-20230812203858054.png" alt="image-20230812203858054"></p><p>其实埋这个坑的原因是为了介绍一下解决依赖冲突的方法，这里推荐一个插件：Maven Helper</p><p><img src="C:\Users\周斌\AppData\Roaming\Typora\typora-user-images\image-20230812204054629.png" alt="image-20230812204054629"></p><p>安装了这个插件，在进入pom文件时就会有下面这个”Dependency Analyzer”按钮：<br><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20240124150632768.png" alt="image-20240124150632768"></p><p>点击这个按钮，就会进入到上面第一张图中的界面，里面将各个依赖的关系罗列的很清楚，像出现了log方面的依赖冲突，就可以直接在搜索框搜索”log“，就可以看到在上面第一张图中关于log的依赖都被标识出来了，可以看到，除了log4j依赖外，spring-boot-starter-web里有内置的spring-boot-starter-logging依赖，这个时候我们既可以右键spring-boot-starter-logging，点击”Exclude“，插件就自动帮我们把spring-boot-starter-web中的log依赖排除了，很方便。</p><p>个人觉得学会排除重复依赖的方法还是满重要的，所以不要怪我前面埋坑喽。</p><p>这个时候刷新maven，启动项目，看到之前彩色的日志全部变成白色的就说明log4j整合完成了。</p><h2 id="基于disruptor实现异步日志："><a href="#基于disruptor实现异步日志：" class="headerlink" title="基于disruptor实现异步日志："></a>基于disruptor实现异步日志：</h2><p>其实前面的内容都是铺垫，我最想记录就是这一点，在大项目中，或许每秒都有很多条日志写入文件中，如果不使用异步日志的话，就会导致进程阻塞。</p><blockquote><p>在多线程服务程序中，异步日志是必须的，因为如果在网络IO线程或业务线程中直接往磁盘写数据的话，写操作偶尔可能阻塞长达数秒之久。这可能导致请求方超时，活着耽误发送心跳消息，在分布式系统中更可能造成多米诺骨牌效应，例如误报死锁引发自动failover等。</p></blockquote><h3 id="disruptor简介："><a href="#disruptor简介：" class="headerlink" title="disruptor简介："></a>disruptor简介：</h3><p>Disruptor是一个高性能的异步处理框架，它可以帮助我们轻松构建数据流处理。Disruptor的核心思想是使用环形队列来存储事件，然后通过消费者线程来消费这些事件。这种方式可以避免锁和同步器，从而提高性能。</p><h3 id="1-引依赖：-1"><a href="#1-引依赖：-1" class="headerlink" title="1. 引依赖："></a>1. 引依赖：</h3><p>使用disruptor需要引入下面的依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.lmax&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;disruptor&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.4</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-修改xml配置文件："><a href="#2-修改xml配置文件：" class="headerlink" title="2. 修改xml配置文件："></a>2. 修改xml配置文件：</h3><p>使用异步日志，需要将xml文件里的配置修改一下，主要就是将<AsyncLogger>这块注释去了，将<root>注释掉：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">AsyncLogger</span> <span class="attr">name</span>=<span class="string">&quot;asyncLog&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileInfo&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">AsyncLogger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">AsyncRoot</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> <span class="attr">includeLocation</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFileInfo&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">AsyncRoot</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--        &lt;root level=&quot;info&quot;&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;appender-ref ref=&quot;Console&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;appender-ref ref=&quot;RollingFileInfo&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;appender-ref ref=&quot;RollingFileWarn&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;appender-ref ref=&quot;RollingFileError&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;appender-ref ref=&quot;fileLog&quot;/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;/root&gt;--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-在启动类上加配置："><a href="#3-在启动类上加配置：" class="headerlink" title="3. 在启动类上加配置："></a>3. 在启动类上加配置：</h3><p>使用异步日志还需要再启动类上加上这一句固定配置”System.setProperty(“Log4jContextSelector”, “org.apache.logging.log4j.core.async.AsyncLoggerContextSelector”);”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Log4jTestApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.setProperty(<span class="string">&quot;Log4jContextSelector&quot;</span>, <span class="string">&quot;org.apache.logging.log4j.core.async.AsyncLoggerContextSelector&quot;</span>);</span><br><span class="line">        SpringApplication.run(Log4jTestApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试异步日志："><a href="#测试异步日志：" class="headerlink" title="测试异步日志："></a>测试异步日志：</h2><p>简单写一个测试类，向文件中写入10000条日志，测试对比一下使用异步日志和不使用的效率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/testLog&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLog</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">          log.info(<span class="string">&quot;这是&#123;&#125;条日志！&quot;</span>, i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">      log.info(<span class="string">&quot;当前耗时：&#123;&#125;&quot;</span>, endTime - startTime);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>未使用异步日志，耗时2907ms，使用异步日志，耗时158ms，可以看到效率提升还是满明显的。</p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><p>在springboot项目中整合log4j需要注意排除springboot内置日志框架，使用disruptor异步日志可以大幅提升日志记录性能。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> disruptor </tag>
            
            <tag> 异步日志 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot3.x整合Swagger</title>
      <link href="/2023/08/12/study-2/"/>
      <url>/2023/08/12/study-2/</url>
      
        <content type="html"><![CDATA[<p>最近做了个小调查，问了我周围的Java伙伴们他们的spring和springboot的版本，发现居然没人用最新的spring6.x和springboot3.x，想想也正常，毕竟程序员们都听过“用旧不用新”的忠告，不过呢，我个人是比较喜欢探索新事物的，所以在spring6.x和springboot3.x刚出来不久就开始使用了，也因此吃了很多版本不兼容的亏，我的博客里就记录了好几次，这不今天又喜提一个——Springboot3.x整合Swagger。</p><h2 id="Swagger简介："><a href="#Swagger简介：" class="headerlink" title="Swagger简介："></a>Swagger简介：</h2><p>Swagger 是一个规范和工具集，用于设计、构建、文档化和使用 RESTful 风格的 Web 服务。它提供了一套简洁易用的接口描述语言（OpenAPI Specification）和交互式文档、代码生成器、测试工具等。</p><p>以下是 Swagger 的一些主要特点和优势：</p><ol><li>接口描述语言（OpenAPI Specification）: Swagger 使用基于 JSON 或 YAML 的接口描述语言来定义 API 的结构、参数、返回值等信息。这样可以使开发人员更好地理解和使用接口，提高开发效率。</li><li>交互式文档：Swagger 自动生成交互式的 API 文档，通过 Web 界面提供了一种直观的方式来查看和测试 API。它包含了所有接口的详细说明、参数验证规则、示例请求和响应等信息，可以方便开发人员和其他团队成员快速了解和使用 API。</li><li>代码生成器：Swagger 可以根据接口描述文件自动生成客户端代码，支持多种语言和框架，包括 Java、Python、JavaScript、Go 等。这样可以加速客户端的开发过程，并保持与服务端的接口定义一致性。</li><li>API 测试工具：Swagger 提供了一个内置的 API 测试工具，可以直接在文档页面上对 API 进行测试。开发人员可以通过该工具发送请求，并查看请求和响应的详细信息，从而快速验证 API 的正确性和稳定性。</li><li>生态系统丰富：Swagger 拥有一个庞大的开源社区和丰富的生态系统，提供了许多与 Swagger 兼容的工具和插件。这些工具可以与各种开发框架和平台集成，为开发人员提供更多的选择和便利。</li></ol><p>简单来说，Swagger就是一个接口测试工具，与PostMan、APIpost类似，不过由于Swagger具有代码侵入性，所以其实是不建议用的，不过在卷到飞起的今天，该掌握还是得掌握的。</p><h2 id="编写一个简单的测试接口："><a href="#编写一个简单的测试接口：" class="headerlink" title="编写一个简单的测试接口："></a>编写一个简单的测试接口：</h2><p>首先编写一个测试接口，这里就写了个很简单的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/get&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;测试&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Springboot2-x整合Swagger："><a href="#Springboot2-x整合Swagger：" class="headerlink" title="Springboot2.x整合Swagger："></a>Springboot2.x整合Swagger：</h2><p>我最开始用的是Springboot2.x整合Swagger的方式，结果由于版本不兼容出现了一些问题，但是方法是对的，也就记录一下吧。</p><p>其实Java整合各种组件的基本流程就是：引依赖-&gt;写配置类-&gt;在配置文件里开启，那就从头开始说说吧。</p><h3 id="1-引依赖："><a href="#1-引依赖：" class="headerlink" title="1. 引依赖："></a>1. 引依赖：</h3><p>Swagger需要的依赖就下面两个，一个是UI界面依赖，一个核心依赖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;<span class="number">2.7</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;<span class="number">2.7</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-写配置类："><a href="#2-写配置类：" class="headerlink" title="2. 写配置类："></a>2. 写配置类：</h3><p>新建一个SwaggerConfig的类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Docket <span class="title function_">api</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Docket</span>(DocumentationType.SWAGGER_2)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.bin.swaggerdemo.controller&quot;</span>))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build()</span><br><span class="line">                .apiInfo(apiInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApiInfo <span class="title function_">apiInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ApiInfoBuilder</span>()</span><br><span class="line">                .title(<span class="string">&quot;接口文档&quot;</span>)</span><br><span class="line">                .description(<span class="string">&quot;接口文档&quot;</span>)</span><br><span class="line">                .version(<span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 api() 方法中，我们通过 `select() 方法配置扫描的包路径，paths() 方法配置接口的访问路径，apiInfo() 方法配置接口文档的相关信息，@Configuration 表示该类是一个配置类，@EnableSwagger2 表示启用 Swagger。</p><h3 id="3-写配置文件："><a href="#3-写配置文件：" class="headerlink" title="3. 写配置文件："></a>3. 写配置文件：</h3><p>Springboot2.x整合Swagger,如果不需要自定义配置上面的title、description、version这些内容，就不需要在配置文件里写什么。</p><h2 id="版本不兼容导致的问题："><a href="#版本不兼容导致的问题：" class="headerlink" title="版本不兼容导致的问题："></a>版本不兼容导致的问题：</h2><h3 id="1-问题描述："><a href="#1-问题描述：" class="headerlink" title="1. 问题描述："></a>1. 问题描述：</h3><p>如果是Springboot2.x到这就已经整合好了，可惜我用的是Springboot3.x，然后就报错啦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.NoClassDefFoundError: org/springframework/util/comparator/InvertibleComparator</span><br><span class="line">at org.springframework.plugin.core.OrderAwarePluginRegistry.&lt;clinit&gt;(OrderAwarePluginRegistry.java:<span class="number">45</span>) ~[spring-plugin-core-<span class="number">1.2</span><span class="number">.0</span>.RELEASE.jar:na]</span><br><span class="line">at org.springframework.plugin.core.support.PluginRegistryFactoryBean.getObject(PluginRegistryFactoryBean.java:<span class="number">36</span>) ~[spring-plugin-core-<span class="number">1.2</span><span class="number">.0</span>.RELEASE.jar:na]</span><br><span class="line">at org.springframework.plugin.core.support.PluginRegistryFactoryBean.getObject(PluginRegistryFactoryBean.java:<span class="number">28</span>) ~[spring-plugin-core-<span class="number">1.2</span><span class="number">.0</span>.RELEASE.jar:na]</span><br><span class="line">at org.springframework.beans.factory.support.FactoryBeanRegistrySupport.doGetObjectFromFactoryBean(FactoryBeanRegistrySupport.java:<span class="number">148</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">... <span class="number">71</span> common frames omitted</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: org.springframework.util.comparator.InvertibleComparator</span><br><span class="line">at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:<span class="number">641</span>) ~[na:na]</span><br><span class="line">at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:<span class="number">188</span>) ~[na:na]</span><br><span class="line">at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">521</span>) ~[na:na]</span><br><span class="line">... <span class="number">75</span> common frames omitted</span><br></pre></td></tr></table></figure><p>这日志就不解读了（其实我也看不太懂，咳咳），不过百度了一下，也没找到好的解决方案。</p><h3 id="2-探究过程："><a href="#2-探究过程：" class="headerlink" title="2. 探究过程："></a>2. 探究过程：</h3><p>检查了接口代码、配置类代码确保没问题，我就想到可能因为依赖的版本低不兼容了，其实我在mvn仓库引依赖时就发现springfox-swagger2这依赖2020年后就不更新了，我居然天真的认为是技术已经很成熟了，然后傻乎乎的引入了上面最新的3.0版本的依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;<span class="number">3.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;<span class="number">3.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>还是报错，不过这次的报错信息短了很多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.ClassNotFoundException: javax.servlet.http.HttpServletRequest</span><br><span class="line">at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:<span class="number">641</span>) ~[na:na]</span><br><span class="line">at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:<span class="number">188</span>) ~[na:na]</span><br><span class="line">at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">521</span>) ~[na:na]</span><br><span class="line">at java.base/java.lang.Class.forName0(Native Method) ~[na:na]</span><br><span class="line">at java.base/java.lang.Class.forName(Class.java:<span class="number">496</span>) ~[na:na]</span><br><span class="line">at java.base/java.lang.Class.forName(Class.java:<span class="number">475</span>) ~[na:na]</span><br><span class="line">at java.base/sun.reflect.generics.factory.CoreReflectionFactory.makeNamedType(CoreReflectionFactory.java:<span class="number">114</span>) ~[na:na]</span><br><span class="line">... <span class="number">32</span> common frames omitted</span><br></pre></td></tr></table></figure><p>其实经验告诉我，每次报错信息中有“~[spring-boot-3.1.2.jar:3.1.2]”这种，差不多就是spring/springboot版本不兼容导致的问题，然后喝了杯水冷静了一下，搜索了“springboot3整合Swagger”，得到了答案。</p><h2 id="springboot3整合Swagger："><a href="#springboot3整合Swagger：" class="headerlink" title="springboot3整合Swagger："></a>springboot3整合Swagger：</h2><p>还是那几步。</p><h3 id="1-引依赖：-1"><a href="#1-引依赖：-1" class="headerlink" title="1. 引依赖："></a>1. 引依赖：</h3><p>因为集成SpringFox只支持SpringBoot2.x，而基于Swagger的SpringDoc的社区现在十分活跃，版本不断更新。SpringFox自从2020年7月14号之后就不更新了，官方建议是springdoc替代springfox。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springdoc&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;springdoc-openapi-starter-webmvc-ui&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;<span class="number">2.0</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">     &lt;!-- 官方建议是springdoc替代springfox--&gt;</span><br><span class="line">     &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;org.springdoc&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;springdoc-openapi-starter-webmvc-api&lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;<span class="number">2.0</span><span class="number">.4</span>&lt;/version&gt;</span><br><span class="line">     &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="2-写配置类：-1"><a href="#2-写配置类：-1" class="headerlink" title="2. 写配置类："></a>2. 写配置类：</h3><p>SpringDoc的配置类比上面springfox的配置类简单些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwaggerConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> OpenAPI <span class="title function_">springShopOpenAPI</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpenAPI</span>()</span><br><span class="line">                .info(<span class="keyword">new</span> <span class="title class_">Info</span>().title(<span class="string">&quot;Swagger&quot;</span>)</span><br><span class="line">                        .description(<span class="string">&quot;abin&quot;</span>)</span><br><span class="line">                        .version(<span class="string">&quot;v1&quot;</span>)</span><br><span class="line">                        .license(<span class="keyword">new</span> <span class="title class_">License</span>().name(<span class="string">&quot;Apache 2.0&quot;</span>).url(<span class="string">&quot;http://springdoc.org&quot;</span>)))</span><br><span class="line">                .externalDocs(<span class="keyword">new</span> <span class="title class_">ExternalDocumentation</span>()</span><br><span class="line">                        .description(<span class="string">&quot;外部文档&quot;</span>)</span><br><span class="line">                        .url(<span class="string">&quot;https://springshop.wiki.github.org/docs&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也还是配置了上面的哪些信息，springdoc里不需要@EnableSwagger2注解。</p><h3 id="3-写配置文件：-1"><a href="#3-写配置文件：-1" class="headerlink" title="3. 写配置文件："></a>3. 写配置文件：</h3><p>使用springdoc需要在配置文件里指定swagger的ui界面访问路径：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">springdoc:</span><br><span class="line">  swagger-ui:</span><br><span class="line">    path: /swagger-ui.html</span><br></pre></td></tr></table></figure><h3 id="4-启动项目测试："><a href="#4-启动项目测试：" class="headerlink" title="4. 启动项目测试："></a>4. 启动项目测试：</h3><p>启动项目，没有报错，浏览器访问<a href="http://localhost:8080/swagger-ui/index.html#/，出现Swagger接口测试界面：">http://localhost:8080/swagger-ui/index.html#/，出现Swagger接口测试界面：</a></p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image-20230811094036252.png" alt="image-20230811094036252"></p><p>选择我们创建好的test/get接口，点击“try it out”进行测试，响应200，表示请求成功，到此swagger整合完成。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>本文只是简单介绍了Springboot整合swagger的方式，Swagger还有一些高级应用，可以阅读官方文档了解，springboot2.x与springboot3.x中很多组件的整合方式都不同，需要整合时，先看看官方文档，可以少走很多弯路。最后，你们的spring/springboot是什么版本呢？</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swagger </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>忙里偷闲-特种兵3日半游重庆成都</title>
      <link href="/2023/08/08/trip-2/"/>
      <url>/2023/08/08/trip-2/</url>
      
        <content type="html"><![CDATA[<p>实习被鸽啦，秋招居然马上开始了，真快啊，感觉简历还是一片空白，烦闷，刚好朋友喊我去旅游，我也觉得是时候出去散散心了，于是简单规划，决定特种兵式3日半游重庆和成都。</p><h2 id="多磨的开始："><a href="#多磨的开始：" class="headerlink" title="多磨的开始："></a><strong>多磨的开始：</strong></h2><p>之前五一时就在抖音上看见过：有酒店为了涨价，打电话给已经订过房的客人打电话说酒店要装修，要求退房。谁能想到这么快就照进自己的现实了，在旅程开始的前两天我都在维权，具体的维权过程我过两天梳理下单独写一篇小tip吧。</p><p>终于坐上了去往重庆的硬座，西安和重庆看着不是很远，火车居然要坐9小时，离谱。上了火车，找了座位，一个大哥找我换座位，我换了，刚找到大哥的座位，一位阿姨又要和我换，说出来我自己都不信，我就这样换了六次，结果居然坐到了我朋友的旁边，我以为开始走运了。</p><p>十点多，朋友买了泡面，我说我打算凌晨一点多吃，谁知道这个决定让一桶泡面跟着我走完了全程（西安-重庆-成都-西安）。安康站到了，一位叔叔说我坐了他的位置，我才突然想起来最开始换座位时一直没有问他们的终点站，我也不知道到底谁在安康站下了，关键是这叔叔要看孩子，所以没法换座，无奈我只能去到我原来的座位，安逸的两人座变回了三人座，我还在最外边 ，没有桌子，可怜我的泡面还没吃。</p><p>三人座的最外边睡觉也很难受，趴都没地方趴，勉勉强强眯一会还会被路过的人碰醒，后面的大叔还在喋喋不休的说着自己的见多识广，对面的大叔大妈光着脚睡觉，旁边站着的大叔身上有股怪异的味道…</p><h2 id="看人生百态："><a href="#看人生百态：" class="headerlink" title="看人生百态："></a><strong>看人生百态：</strong></h2><p>我以为这已经是最坏的情况了，结果火车不知道什么原因中途停车了，12306显示预计晚点71分钟，我晕。</p><p>一位老爷爷找了张报纸在我旁边的过道坐了下来。对面的大妈大叔也醒了过来，大叔给大妈递水递面包，大妈也会让大叔吃面包，他们的孩子盖着一张毯子睡的很熟，平淡中透露着甜蜜，让人羡慕。</p><p>左斜方的叔叔起身不知道干什么去了，一位面色不是很好的阿姨趁机坐了下来，坐在楼道的那位老爷爷笑着说道：“对着滴，人走了你就赶紧歇会”，他俩交谈中，得知这位阿姨的丈夫在西藏生病了，好像还挺严重，她需要过去把他丈夫接回来，有点心疼。</p><p>旁边的两个男孩应该比我小那么一两岁，他俩第一次坐硬座，他们说是来感受生活的，下次再也不坐了。我觉得其实硬座虽然很难受，但也还是能接受。</p><p>左边的靠窗位置坐着一个男孩，初中生的样子，他的妈妈和小姨坐在我背后，小孩想和他小姨换座位，她妈妈说：“不换，我有点嫌弃他”，男孩来了一句：“家人们，谁懂啊”，看不太懂，有点难评。</p><p>……</p><p>有时间去感受一下硬座吧，看看世间百态，挺好的。</p><h2 id="重庆："><a href="#重庆：" class="headerlink" title="重庆："></a><strong>重庆：</strong></h2><h3 id="1-李子坝"><a href="#1-李子坝" class="headerlink" title="1. 李子坝"></a>1. 李子坝</h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/1.jpeg" alt=""></p><p>早就听说重庆有开进楼房里的火车，下了火车就坐上了去李子坝的地铁，据说在驾驶室后一节车厢的观感最好，坐上了，但是什么也没看见…下地铁，下了不知道多少层楼，终于到了所谓的最佳拍摄点（楼里面原来是有拍摄点的，但是现在好像都被挡住不让进了），其实也没有想象中的那么震撼。</p><h3 id="2-重庆小面"><a href="#2-重庆小面" class="headerlink" title="2. 重庆小面"></a>2. <strong>重庆小面</strong></h3><p>坐了一晚上的火车，那桶泡面还没吃，早就饿了，来重庆当然要试试重庆小面啦，就近找了一家，说实话，除了比学校的小面味道重了一点，其他也没什么特别的，也没有很辣，但是里面的菜是一种我没见过的菜，空心的杆，叶子有点像红薯叶。店主夸夸其谈说他家的面是最好吃的，我当然只当说笑了，但是后两天我确实没吃到比这更好吃的小面了（这家的面10块1两，后面的面9块2两，可能是因为便宜，所以里面居然没有我最爱吃的豌豆粒！）。</p><h3 id="3-鹅岭二厂"><a href="#3-鹅岭二厂" class="headerlink" title="3. 鹅岭二厂"></a>3. <strong>鹅岭二厂</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/2.jpeg" alt=""></p><p>重庆真的是个神奇的城市，8D城市让高德地图崩溃，让我更崩溃，跟着导航走居然走到别人家门口去了（应该也是从李子坝到鹅岭二厂的一条路线，之前在抖音好像看见过有从居民楼上去的路线），看导航不如看哪条路上的小摊多。小tip：去鹅岭二厂的路上的扇子是最便宜的，8r/把，后面再没见过这个价以下的了。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/3.jpeg" alt="3"></p><p>鹅岭二厂是个什么样的地方呢？我还真概括不上来，我只能说墙上写满了明星爱豆的名字、有“此生必驾318”的打卡牌、有一个可以看见重庆全貌的观景台（据说是《从你的全世界路过》的取景地，但是我是真看不出来）…</p><h3 id="4-鹅岭公园"><a href="#4-鹅岭公园" class="headerlink" title="4. 鹅岭公园"></a>4. <strong>鹅岭公园</strong></h3><p>重庆的蝉意外的聒噪，只要有树的地方就能听见蝉鸣，那声音比学校发电机的声音更大更刺耳。</p><p>鹅岭公园距离鹅岭二厂不远，去那里主要是为了休息并安排一下行程，没怎么逛，看了丹麦公使馆旧址，去了艺卉园，里面有很多锦鲤，希望看完能有好运吧。</p><p>据说还有石绳桥，鹅项山庄等等，可惜没仔细去逛。</p><h3 id="5-磁器口"><a href="#5-磁器口" class="headerlink" title="5. 磁器口"></a>5. <strong>磁器口</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/4.jpeg" alt="4"></p><p>重庆的地铁口很难找，鹅岭公园下来，明明看见导航上地铁口就在附近，找了一圈愣是没找到，最后发现那个看着像地下通道的口就是地铁口…</p><p>磁器口和南京夫子庙一样，就是一个商业街，街上各种文创馆，糕点店，不过多了火锅底料店，一路上疯狂试吃。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/5.jpeg" alt="5"></p><p>小tip：不要在景区消费！遇见了一个童年回忆的店铺，朋友是一个怀念童年的人，结果遇到了童年刺客，上面这两样原来总共只要1块钱的零食卖了朋友10块钱，消费童年情怀，简直暴利。</p><h3 id="6-渣滓洞-amp-白公馆"><a href="#6-渣滓洞-amp-白公馆" class="headerlink" title="6. 渣滓洞&amp;白公馆"></a>6. <strong>渣滓洞&amp;白公馆</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/6.jpeg" alt="6"></p><p>出了磁器口，找到公交站，会有专门的“红岩巴士”，一张票20元，有四张副劵，在这条线路上可以坐四次，还是挺划算的，可惜到最后我们也只用了两次。</p><p>去的时候的巴士很舒服，空调、真皮座椅…先去了白公馆，这时候已经是11点了，白公馆在半山腰，渣滓洞比白公馆地势低一些，先去了白公馆，毕竟是监狱，在屋子里面很闷很热，接着去了渣滓洞，人太多，很热，没进去，反正到过了。</p><h3 id="7-解放碑-amp-八一好吃街"><a href="#7-解放碑-amp-八一好吃街" class="headerlink" title="7. 解放碑&amp;八一好吃街"></a>7. <strong>解放碑&amp;八一好吃街</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/7.jpeg" alt="7"></p><p>小tip：酒店订在解放碑附近很方便，很多地方走着就到了。解放碑：标志性建筑。</p><p>八月一日逛八一好吃街，还挺巧，其实在八一好吃街附近还有各种名字的好吃街，都大差不差，里面的吃的挺像的，挺贵的。吃了烤苕皮，说实话，和西安地摊的味道差不多。</p><h3 id="8-洪崖洞-amp-千厮门大桥"><a href="#8-洪崖洞-amp-千厮门大桥" class="headerlink" title="8. 洪崖洞&amp;千厮门大桥"></a>8. <strong>洪崖洞&amp;千厮门大桥</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/8.jpeg" alt="8"></p><p>重庆最好看的夜景应该就是洪崖洞了吧，坐地铁过千厮门大桥时刚好赶上洪崖洞亮灯，那一瞬间我脑海只有三个字“真好看”，似乎是地铁的窗户给了一层特殊的滤镜，后面下了地铁我想拍出那种感觉却怎么也拍不出来。</p><p>不赶巧，走在千厮门大桥中间时，大桥亮灯了，而且只亮了一分钟，没有拍到（但是第二天晚上，居然亮了很久！）。</p><p>洪崖洞人真的超级多！虽然只是路过，但是还是被堵住了，不过还好，走了一会儿交警把公路暂时挡住疏散人流，我们路过的赶紧跑走了，途中一个大哥还喊着“冲啊！杀啊！”有点意思。</p><h3 id="9-湖广会馆"><a href="#9-湖广会馆" class="headerlink" title="9. 湖广会馆"></a>9. <strong>湖广会馆</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/9.jpeg" alt="9"></p><p>刷抖音看见湖广会馆不知道在哪，早上过酒店门口的大桥去龙门浩老街时，发现，这不就在酒店门口嘛，不过要门票，主打一个穷游，看看不进。</p><h3 id="10-龙门浩老街"><a href="#10-龙门浩老街" class="headerlink" title="10. 龙门浩老街"></a>10. <strong>龙门浩老街</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/10.jpeg" alt="10"></p><p>过桥下电梯就到了龙门浩老街，有一半还没开发完，另一半呢emmm，各种咖啡馆，酒馆，小书屋，环境还是不错的，在这里喝杯咖啡体验应该还不错，可惜，穷，只能想象。这里有一个博物馆，里面有很多佛像，经书，佛学爱好者可以去看看。</p><h3 id="11-重庆市动物园"><a href="#11-重庆市动物园" class="headerlink" title="11. 重庆市动物园"></a>11. <strong>重庆市动物园</strong></h3><p>说实话，第一次逛动物园，才知道动物园居然这么大。</p><p>来的有点迟了，很多动物都休息了，最可惜的就是没有看见熊猫。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/11.jpeg" alt="11"></p><p>这只猴子他会冲人笑，可惜笑的那张没拍好。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/12.jpeg" alt="12"></p><p>我有点分不清那是它的耳朵还是脸庞。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/13.jpeg" alt="13"></p><p>这只猩猩在耍宝 不知道它在想些什么呢？</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/14.jpeg" alt="14"></p><p>华为的手机拍照时，放大到一定倍数，手机会通过算法自动补帧，这张是不是科技补的太过了，但是它的表情好憨，像极了列表中的某个人。</p><p>还有很多动物，老虎、狮子、犀牛、斑马、河马、龟、蛇、各种鸟…还不错。</p><h3 id="12-钟书阁"><a href="#12-钟书阁" class="headerlink" title="12. 钟书阁"></a>12. <strong>钟书阁</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/15.jpeg" alt="15"></p><p>很大的一个书店，里面的书应该很全吧，装饰的很漂亮，只可惜成了网红打卡点，里面多了很多嘈杂。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/16.jpeg" alt="16"></p><p>也有很多人在里面安静的看书，在这个快节奏的时代，安静的坐下来看看书也是很惬意的吧。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/17.jpeg" alt="17"></p><p>和朋友在这里买了三块石头，每块18，不是很值，但是我们觉得值，挺好看。</p><h3 id="13-白象居"><a href="#13-白象居" class="headerlink" title="13. 白象居"></a>13. <strong>白象居</strong></h3><p>其实就是老式居民楼，据说出名的原因是二十九层没有电梯。在这上面可以拍到长江索道，其实我个人不太喜欢去别人住的地方去打卡的，上去看见那些居民还是挺尴尬的，也会觉得自己打扰到了他们。</p><h3 id="14-十八梯"><a href="#14-十八梯" class="headerlink" title="14. 十八梯"></a>14. <strong>十八梯</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/18.jpeg" alt="18"></p><p>又一条商业街，据说也是《从你的全世界路过》取景地，这看着还是有点像。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/19.jpeg" alt="19"></p><p>为什么叫十八梯，可能因为是从半山腰到山脚有十八段台阶？但是我感觉不止啊。</p><h3 id="15-山城步道"><a href="#15-山城步道" class="headerlink" title="15. 山城步道"></a>15. <strong>山城步道</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/20.jpeg" alt="20"></p><p>这个地方！！！很奇怪，从山脚下上去的第一段是商业街，和十八梯差不多，第二段开始就比较奇怪了，还是石阶，但是由于没有商铺，所以人很少，第三段走进了人家的居民楼的巷子里了，第四段，走着走着又到了一小段商业街，第五段，开始爬山，就是那种沿山石阶，开始还有几个人，越走人越少，路也越敷衍，到最后只有我和朋友两个人了，走到了一个房子后面，眼看着要上马路了，结果没路了…然后返回时有个岔路口，从岔路口下去会到马路，沿着马路走会走到街道上去。</p><p>小tip：这个地方后半段就是爬山，不想爬山的话，感觉不对就返回吧。</p><p>也就是因为这个山城步道耽误的时间有点长，原计划的涂鸦一条街就去不了了。</p><h3 id="16-朝天门"><a href="#16-朝天门" class="headerlink" title="16. 朝天门"></a>16. <strong>朝天门</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/21.jpeg" alt="21"></p><p>朋友说看洪崖洞时没看到朝天门正面，也确实，朝天门正面在龙门浩老街那岸，于是我们又回到了龙门浩老街，坐上了去看朝天门正面的公交。</p><p>不得不说，一个城市看起来是不是繁华，夜晚灯光要起一半作用，重庆的夜景看起来真的很漂亮，各种颜色的楼让人着迷。</p><p>回去的路上我和朋友谈论起以后的归途，他说“大城市很好，可是我们只是游客，这些城市终究不会有我们的位置。”，是啊，有人一生来就在罗马，有人一辈子都到不了罗马，现在的阶级跨越真难啊。</p><h3 id="17-周孃孃火锅"><a href="#17-周孃孃火锅" class="headerlink" title="17. 周孃孃火锅"></a>17. <strong>周孃孃火锅</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/22.jpeg" alt="22"></p><p>回到酒店附近，问了小卖部的姐姐哪里的火锅好吃，姐姐给我们说了家附近的居民楼火锅。到了店，我看见有一个锅正在洗，里面的洗锅水很脏，虽然这是洗锅水，但是我还是拉着朋友走了，这种东西不看见吃了也就吃了，但是看见了，我心里总会觉得有点ex。</p><p>找了家评价还不错的火锅，周孃孃火锅，也是个居民楼火锅，人还挺多，美团点了个双人套餐，加了四个菜。小tip：两个人吃火锅真吃不了多少，饭量小点的话一个双人套餐就够了。</p><p>在吃的过程中孃孃到了我们后面那桌让她们给好评，后面那桌那个阿姨说“其他我可以给五星，但是味道我真给不了五星，因为我吃过很多次火锅，你们这味道真的不是那么好。”然后孃孃说“那你就别发了”，我算是知道美团上的好评怎么来的了，我有点分不清到底什么是真的了。</p><p>吃完，孃孃过来要好评，我把手机给她让她自己弄了，说实话，味道确实一般，不过还好，吃完没拉肚子。</p><h3 id="18-彩蛋"><a href="#18-彩蛋" class="headerlink" title="18. 彩蛋"></a>18. <strong>彩蛋</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/23.jpeg" alt="23"></p><p>这栋楼我一直不知道叫什么名字，白天是金色的(后面查了是喜来登大酒店)。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/24.jpeg" alt="24"></p><p>晚上它会变色，变成银色的时候很炫酷，可惜我没拍下来，它叫什么名字呢？</p><h3 id="离开"><a href="#离开" class="headerlink" title="离开"></a><strong>离开</strong></h3><p>不整理不知道，一整理居然去了这么多地方，重庆真的很繁华，也很有特色，可惜没钱没时间，没有好好逛完，还有很多地方没去：观音桥街道、涂鸦一条街、夜景公园、老君庙…据说正在修西安到重庆的新线路，修好后西安到重庆只需要2.5小时，以后会有钱会有时间，只是以后再来时，还会有现在的心境吗？欲买桂花同载酒，终不似，少年游。</p><h2 id="成都"><a href="#成都" class="headerlink" title="成都"></a><strong>成都</strong></h2><p>成都，印象中是一个满普通的城市（相较于那些特征明确的城市）。成都很多景区都不在市区内，时间原因，我们只能在市区逛了一圈，毕竟是开大运会的城市，也还是满繁华，成都街上，真的三步一个火锅店。</p><h3 id="1-青旅蜗牛仓"><a href="#1-青旅蜗牛仓" class="headerlink" title="1. 青旅蜗牛仓"></a>1. <strong>青旅蜗牛仓</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/25.jpeg" alt="25"></p><p>在春熙路附近订了蜗牛仓，60r/人，还是挺划算，看着也还炫酷，不过还是不如酒店那么自由，而且晚上很热，开着风扇换气还是很热，没有浴巾和牙具，有点难受。</p><h3 id="2-太古里"><a href="#2-太古里" class="headerlink" title="2. 太古里"></a>2. <strong>太古里</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/26.jpeg" alt="26"></p><p>这一条街是各种奢侈品店，很多品牌都都不认识，说实话，还是会有点自卑的。</p><h3 id="3-锦里"><a href="#3-锦里" class="headerlink" title="3. 锦里"></a>3. <strong>锦里</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/27.jpeg" alt="27"></p><p>商业街，还蛮大的，和其他商业街不太一样的就是，成都的商业街会有很多茶馆，然后我们就被坑了。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/28.jpeg" alt="28"></p><p>说的是28r/位，以为是56r一壶茶，然后和朋友想着也不贵就进去了，进去坐下，才知道28r/位，是看表演的价格，喝茶需要另外付钱，一碗茶最低38r，一碗茶送三个表演，迫于面子，我和朋友一人点了一碗48r的茶，含泪看了三个节目，一个长嘴壶茶艺表演，一个看不懂得戏剧表演，一个变脸，可惜三个节目都之前都看过，不值！</p><h3 id="4-宽窄巷子"><a href="#4-宽窄巷子" class="headerlink" title="4. 宽窄巷子"></a>4. <strong>宽窄巷子</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/29.jpeg" alt="29"></p><p>又一经典商业街，人真的很多，唉，果然，旅游就是去看人去了。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/30.jpeg" alt="30"></p><p>这个商业街上有一些银器点，里面有银锭，银票，银镯子，看的的眼花。</p><h3 id="5-路景"><a href="#5-路景" class="headerlink" title="5. 路景"></a>5. 路景</h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/31.jpeg" alt="31"></p><p>看这两栋楼还长耳朵了，挺好看。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/32.jpeg" alt="32"></p><p>拍了远处不知道什么地方的楼，也还不错。</p><h3 id="6-九眼桥"><a href="#6-九眼桥" class="headerlink" title="6. 九眼桥"></a>6. <strong>九眼桥</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/33.jpeg" alt="33"></p><p>这张好像不是九眼桥，导航显示九眼桥是我拍照站的那座桥，不过，管他呢，这座桥也好看。</p><p>九眼桥这边有一条酒吧街，沿街全是酒吧，也有很多人在外面拉客，喜欢去酒吧玩的可以去看看。</p><p>成都相比重庆有个优点就是，有共享单车，可以骑着单车看夜景，很奈斯。</p><h3 id="7-天府广场"><a href="#7-天府广场" class="headerlink" title="7. 天府广场"></a>7. <strong>天府广场</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/34.jpeg" alt="34"></p><p>不知道朋友为什么会对天府广场有执念，一到成都就说要去，终于还是去了，就是一个普通的广场，下面是一个商业广场。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/35.jpeg" alt="35"></p><p>小tip：天府广场、四川科技馆、成都博物馆都在一起，可以一起玩，我们就是没好好做攻略，逛完天府广场走了，后面成都博物馆又回来了。</p><h3 id="8-天府公园"><a href="#8-天府公园" class="headerlink" title="8. 天府公园"></a>8. <strong>天府公园</strong></h3><p>呀呀呀，这是个意外，看错导航了，明明是天府艺术公园，可以去看艺术馆，结果坐上了去天府公园的地铁，想着都坐上了，不如去看看，结果啥都没有，连人都没有，可能是地理位置太远了吧，地铁要坐一个小时。</p><p>时间耽误的有点多了，由于要赶高铁，所以艺术馆就只能放弃了。</p><h3 id="9-成都博物馆"><a href="#9-成都博物馆" class="headerlink" title="9. 成都博物馆"></a>9. <strong>成都博物馆</strong></h3><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/36.jpeg" alt="36"></p><p>这是这趟成都之旅最值得地方，很大，从下到上按照朝代从古到今讲述了成都的历史，里面有很多值得一看的地方，想了解成都历史的强推。</p><p>小tip：负一楼里有各种动物的模型，也值得一看。</p><h3 id="10-望平街"><a href="#10-望平街" class="headerlink" title="10. 望平街"></a>10. <strong>望平街</strong></h3><p>这个街道就没什么意思了，一条不是那么繁华的小吃街，很有烟火气 ，其他也没什么。</p><p>成都之旅真的很匆匆，提前没做好攻略，也因为本来就是穷游，很多收费的地方都没去：杜甫草堂、三星堆博物馆…也有很多需要提前预约的地方，要去成都玩得友子们提前做好攻略。</p><h2 id="返程"><a href="#返程" class="headerlink" title="返程"></a><strong>返程</strong></h2><p>“读万卷书，行万里路”，刚好看了《欢颜》，这时候似乎更理解俞亦秀，宁愿放弃话事人的身份也要出去看看，多去看看外面的世界，开阔眼界，提升认知，放松心情，如果可以，我愿意一直在路上，可惜我的钱包时刻提醒自己不要被外面的美化迷住了双眼，该回去了。坐在窗边，看着列车驶进夕阳…旅途结束。</p>]]></content>
      
      
      <categories>
          
          <category> 旅游日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旅游 </tag>
            
            <tag> 重庆 </tag>
            
            <tag> 成都 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis plus内置Mybatis-spring版本问题</title>
      <link href="/2023/07/29/study-1/"/>
      <url>/2023/07/29/study-1/</url>
      
        <content type="html"><![CDATA[<p>最近在做一个写轮子的项目，没想到才刚刚到整合mybatis plus这部分就翻车了，有点难受，这个问题个人觉得还是比较有意思，给大家分享一下。</p><h2 id="问题引出："><a href="#问题引出：" class="headerlink" title="问题引出："></a><strong>问题引出：</strong></h2><p>在项目大体框架搭建完成，引入了mysql和mybatis plus需要的依赖后，写了一个很简单的添加用户的接口测试项目架构时，就报错了：Caused by: java.lang.IllegalArgumentException: Property ‘sqlSessionFactory’ or ‘sqlSessionTemplate’ are required，</p><p>截取部分报错信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">&#x27;userController&#x27;</span>: Unsatisfied dependency expressed through field <span class="string">&#x27;userService&#x27;</span>: Error creating bean with name <span class="string">&#x27;userServiceImpl&#x27;</span>: Unsatisfied dependency expressed through field <span class="string">&#x27;userMapper&#x27;</span>: Error creating bean with name <span class="string">&#x27;userMapper&#x27;</span> defined in file [E:\projects\twig-frame\twig-user\target\classes\com\bin\user\mapper\UserMapper.class]: Property <span class="string">&#x27;sqlSessionFactory&#x27;</span> or <span class="string">&#x27;sqlSessionTemplate&#x27;</span> are required</span><br><span class="line">at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:<span class="number">716</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:<span class="number">696</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:<span class="number">145</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">...</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$<span class="number">0</span>(AbstractBeanFactory.java:<span class="number">326</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:<span class="number">234</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:<span class="number">324</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:<span class="number">200</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:<span class="number">973</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:<span class="number">942</span>) ~[spring-context-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:<span class="number">608</span>) ~[spring-context-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:<span class="number">146</span>) ~[spring-boot-<span class="number">3.1</span><span class="number">.2</span>.jar:<span class="number">3.1</span><span class="number">.2</span>]</span><br><span class="line">at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:<span class="number">734</span>) ~[spring-boot-<span class="number">3.1</span><span class="number">.2</span>.jar:<span class="number">3.1</span><span class="number">.2</span>]</span><br><span class="line">at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:<span class="number">436</span>) ~[spring-boot-<span class="number">3.1</span><span class="number">.2</span>.jar:<span class="number">3.1</span><span class="number">.2</span>]</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="number">312</span>) ~[spring-boot-<span class="number">3.1</span><span class="number">.2</span>.jar:<span class="number">3.1</span><span class="number">.2</span>]</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="number">1306</span>) ~[spring-boot-<span class="number">3.1</span><span class="number">.2</span>.jar:<span class="number">3.1</span><span class="number">.2</span>]</span><br><span class="line">at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="number">1295</span>) ~[spring-boot-<span class="number">3.1</span><span class="number">.2</span>.jar:<span class="number">3.1</span><span class="number">.2</span>]</span><br><span class="line">at com.bin.user.UserApplication.main(UserApplication.java:<span class="number">13</span>) ~[classes/:na]</span><br><span class="line">Caused by: org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name <span class="string">&#x27;userServiceImpl&#x27;</span>: Unsatisfied dependency expressed through field <span class="string">&#x27;userMapper&#x27;</span>: Error creating bean with name <span class="string">&#x27;userMapper&#x27;</span> defined in file [E:\projects\twig-frame\twig-user\target\classes\com\bin\user\mapper\UserMapper.class]: Property <span class="string">&#x27;sqlSessionFactory&#x27;</span> or <span class="string">&#x27;sqlSessionTemplate&#x27;</span> are required</span><br><span class="line">at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:<span class="number">716</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.inject(AutowiredAnnotationBeanPostProcessor.java:<span class="number">696</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:<span class="number">145</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">    ...</span><br><span class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:<span class="number">234</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:<span class="number">324</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:<span class="number">200</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.config.DependencyDescriptor.resolveCandidate(DependencyDescriptor.java:<span class="number">254</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency(DefaultListableBeanFactory.java:<span class="number">1417</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:<span class="number">1337</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:<span class="number">713</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">... <span class="number">20</span> common frames omitted</span><br><span class="line">Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name <span class="string">&#x27;userMapper&#x27;</span> defined in file [E:\projects\twig-frame\twig-user\target\classes\com\bin\user\mapper\UserMapper.class]: Property <span class="string">&#x27;sqlSessionFactory&#x27;</span> or <span class="string">&#x27;sqlSessionTemplate&#x27;</span> are required</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:<span class="number">1770</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:<span class="number">598</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:<span class="number">520</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$<span class="number">0</span>(AbstractBeanFactory.java:<span class="number">326</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:<span class="number">234</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:<span class="number">324</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line"> ...   org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveDependency(DefaultListableBeanFactory.java:<span class="number">1337</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor$AutowiredFieldElement.resolveFieldValue(AutowiredAnnotationBeanPostProcessor.java:<span class="number">713</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">... <span class="number">34</span> common frames omitted</span><br><span class="line">Caused by: java.lang.IllegalArgumentException: Property <span class="string">&#x27;sqlSessionFactory&#x27;</span> or <span class="string">&#x27;sqlSessionTemplate&#x27;</span> are required</span><br><span class="line">at org.springframework.util.Assert.notNull(Assert.java:<span class="number">204</span>) ~[spring-core-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.mybatis.spring.support.SqlSessionDaoSupport.checkDaoConfig(SqlSessionDaoSupport.java:<span class="number">122</span>) ~[mybatis-spring-<span class="number">2.0</span><span class="number">.7</span>.jar:<span class="number">2.0</span><span class="number">.7</span>]</span><br><span class="line">at org.mybatis.spring.mapper.MapperFactoryBean.checkDaoConfig(MapperFactoryBean.java:<span class="number">73</span>) ~[mybatis-spring-<span class="number">2.0</span><span class="number">.7</span>.jar:<span class="number">2.0</span><span class="number">.7</span>]</span><br><span class="line">at org.springframework.dao.support.DaoSupport.afterPropertiesSet(DaoSupport.java:<span class="number">44</span>) ~[spring-tx-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:<span class="number">1817</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:<span class="number">1766</span>) ~[spring-beans-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">... <span class="number">44</span> common frames omitted</span><br></pre></td></tr></table></figure><p>大致就是找不到’sqlSessionFactory’ 或者 ‘sqlSessionTemplate’导致创建不了mapper这个bean，也就导致后续一系列bean都无法创建。</p><h2 id="探究过程："><a href="#探究过程：" class="headerlink" title="探究过程："></a><strong>探究过程：</strong></h2><p>刚好这个报错信息我前两天在使用mybatis时也见过，当时参考了这篇文章：<a href="https://blog.csdn.net/ZHENFENGSHISAN/article/details/128010240">https://blog.csdn.net/ZHENFENGSHISAN/article/details/128010240</a></p><p>大概意思就是：spring6和spring boot3删除了一些类或者方法，但是mybatis还没有同步更新导致的，再简单来说就是mybatis版本与springboot/spring版本不兼容导致的，当然这篇文章作者遇到这个问题时，mybatis还没有更新到3.0x，所以他的解决方案就是配置远程仓库，自己导入兼容性依赖包，但是我遇到这个问题时，mybatis早就更新到了3.0x，只是我在项目中引入的是2.0x,所以我的解决方案很简单：导入mybatis3.0x的依赖，也就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;<span class="number">3.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>当时也是顺利解决了问题，我本以为这次可能是相似的问题，也就是mybatis plus版本与spring/springboot版本不兼容导致的，但是我查看了依赖，发现我的mybatis plus依赖是可以适配springboot3.x的，这个时候就有点大事不好的感觉了，然后我找到了下面三种解决方案：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image.png" alt=""></p><p>由于这个回答针对的也是mybatis使用过程中的问题，我项目中已经导入了mybatis-plus-spring-boot-starter依赖，所以想当然的忽略了方法一，方法二、三我的项目中也都是正确的。</p><p>于是我从头到尾检查了我的项目各部分：代码、数据库配置、MyBatis  plus配置等等，很遗憾没有用发现问题。</p><h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a><strong>解决方案：</strong></h2><p>感觉这只能是依赖的问题了，我又仔细去看了报错的日志，看见了这三句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">at org.springframework.util.Assert.notNull(Assert.java:<span class="number">204</span>) ~[spring-core-<span class="number">6.0</span><span class="number">.11</span>.jar:<span class="number">6.0</span><span class="number">.11</span>]</span><br><span class="line">at org.mybatis.spring.support.SqlSessionDaoSupport.checkDaoConfig(SqlSessionDaoSupport.java:<span class="number">122</span>) ~[mybatis-spring-<span class="number">2.0</span><span class="number">.7</span>.jar:<span class="number">2.0</span><span class="number">.7</span>]</span><br><span class="line">at org.mybatis.spring.mapper.MapperFactoryBean.checkDaoConfig(MapperFactoryBean.java:<span class="number">73</span>) ~[mybatis-spring-<span class="number">2.0</span><span class="number">.7</span>.jar:<span class="number">2.0</span><span class="number">.7</span>]</span><br></pre></td></tr></table></figure><p>后面标注的都是mybatis-spring-2.0.7，我就想是不是mybatis plus内置的mybatis是2.0.7版本的，2.x版与springboot3不兼容导致的问题，于是我单独导入了mybatis-spring-boot-starter3.0版:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;<span class="number">3.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>问题解决。</p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a><strong>小结：</strong></h2><p>Caused by: java.lang.IllegalArgumentException: Property ‘sqlSessionFactory’ or ‘sqlSessionTemplate’ are required，这个报错的排查方向就在依赖和配置文件两方面，而依赖方面就需要排查所需依赖是不是导全了，数据库这块常用的依赖也总结下吧，以后方便点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;<span class="number">3.1</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;<span class="number">1.2</span><span class="number">.16</span>&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;<span class="number">8.0</span><span class="number">.23</span>&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;<span class="number">3.5</span><span class="number">.2</span>&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">   &lt;dependency&gt;</span><br><span class="line">       &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">       &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">       &lt;version&gt;<span class="number">3.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>如果依赖导入没有问题，但是还是报错，就需要考虑依赖于spring/springboot版本是不是兼容了，说实话这块挺烦的，老是因为版本问题遇到一些奇奇怪怪的问题，且行且积累吧。</p><h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a><strong>思考：</strong></h2><p>我专门去看了一下mybatis plus3.5.2的内置依赖，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/4.png" alt=""></p><p>显示的是在mybatis-plus-extension里内置了mybatis-spring:2.0.7，在mybatis-plus-core中内置了mybatis:3.5.10，但是mybatis-spring:2.0.7与springboot3不适配，所以会出问题，有点奇怪为什么mybatis plus3.x中不内置mybatis-spring:3.x而要内置mybatis-spring:2.0.7？有没有大佬解答一下呢？</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>怎么分析设计高并发红包雨系统？</title>
      <link href="/2023/07/20/study-5/"/>
      <url>/2023/07/20/study-5/</url>
      
        <content type="html"><![CDATA[<p>这个问题在一个月前的Lazada面试中遇到过，但是当时胡说八道了一通，也没说到点上，今天逛B站时，发现尚硅谷前两天刚发布了“红包雨系统架构设计”的直播课，课程质量很高，也让我一个月前没理清的思路清晰了很多。</p><p>直播课的讲解路线为：单机-集群-云部署-前后端分离调用，那本文也就按这个顺序记录一下。</p><h2 id="单机模式下需要考虑的问题："><a href="#单机模式下需要考虑的问题：" class="headerlink" title="单机模式下需要考虑的问题："></a><strong>单机模式下需要考虑的问题：</strong></h2><h3 id="1-用什么数据结构安装并记录本次发送的红包？"><a href="#1-用什么数据结构安装并记录本次发送的红包？" class="headerlink" title="1.用什么数据结构安装并记录本次发送的红包？"></a><strong>1.用什么数据结构安装并记录本次发送的红包？</strong></h3><p>比如我们要发100块，分10个包发，该用什么数据结构来记录呢？首先基于高并发下的性能考虑，肯定是使用redis来存储数据，至于用什么数据结构，老师阳哥说的是使用list结构，在发红包时用lpush存，在抢红包时用lpop取。我看见弹幕有人说无序应该用set，当时我觉得还挺有道理的，阳哥应该没看见这弹幕，所以也没说，但是后面我仔细考虑了一下，set它不能重复啊，但是红包的金额是可以重复的，所以用set显然不合适。</p><h3 id="2-大家抢到的红包金额差距不能过大，拆分红包使用什么算法？"><a href="#2-大家抢到的红包金额差距不能过大，拆分红包使用什么算法？" class="headerlink" title="2.大家抢到的红包金额差距不能过大，拆分红包使用什么算法？"></a><strong>2.大家抢到的红包金额差距不能过大，拆分红包使用什么算法？</strong></h3><p>如果抢红包活动中，100块发5个包，其中一个包96，剩余四个各1块，这样的红包分配显然是不合理的，所以得采用算法来控制红包金额的拆分范围，阳哥讲了一种在红包业务中比较通用的算法：二倍均值算法。</p><p>二倍均值算法：</p><p>假设M为总金额，N为抢红包人数，那么根据二倍均值法，每次抢到的金额 = 随机区间 （0， M / N X 2）</p><p>这个公式可以确保每个人获取的金额的平均值是相等的，不会受到先后顺序不同的影响。</p><blockquote><p>比如说，有一个金额为100块的红包，10人分，那么：<br>100/10X2 = 20, 所以第一个人的随机范围是（0，20 )，平均可以抢到10元。<br>假设第一个人随机到10元，那么剩余金额是100-10 = 90 元。<br>90/9X2 = 20, 所以第二个人的随机范围同样是（0，20 )，平均可以抢到10元。<br>假设第二个人随机到10元，那么剩余金额是90-10 = 80 元。<br>80/8X2 = 20, 所以第三个人的随机范围同样是（0，20 )，平均可以抢到10元。<br>以此类推，每一次随机范围的均值是相等的。</p></blockquote><p>代码实现如下（只考虑思路）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer[] splitRedPackageAlgorithm(<span class="type">int</span> totalMoney, <span class="type">int</span> redPackageNumber) &#123;</span><br><span class="line">     Integer[] redPackageNumbers = <span class="keyword">new</span> <span class="title class_">Integer</span>[redPackageNumber];</span><br><span class="line">     <span class="comment">//已经被抢夺的红包金额,已经被拆分塞进子红包的金额</span></span><br><span class="line">     <span class="type">int</span> <span class="variable">useMoney</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; redPackageNumber; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (i == redPackageNumber - <span class="number">1</span>) &#123;</span><br><span class="line">         redPackageNumbers[i] = totalMoney - useMoney;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//二倍均值算法，每次拆分后塞进子红包的金额 = 随机区间(0,(剩余红包金额M ÷ 未被抢的剩余红包个数N) * 2)</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">avgMoney</span> <span class="operator">=</span> ((totalMoney - useMoney) / (redPackageNumber - i)) * <span class="number">2</span>;</span><br><span class="line">         redPackageNumbers[i] = <span class="number">1</span> + <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(avgMoney - <span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         useMoney = useMoney + redPackageNumbers[i];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> redPackageNumbers;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-高并发下怎么抢红包？"><a href="#3-高并发下怎么抢红包？" class="headerlink" title="3.高并发下怎么抢红包？"></a><strong>3.高并发下怎么抢红包？</strong></h3><p>要求做到数据一致性+高可用+不加锁，这种情况应该使用什么技术？首先类似于抢票系统中的“超卖问题”，要保证被抢金额不超过发红包的总金额，这块个人觉得阳哥讲的不是很清楚，在抢票系统中，我们常常使用锁来解决“超卖问题”，可以优化为乐观锁解决问题，但是在红包雨系统中，所有人都要去操作一个红包，所以肯定不能加锁，也就是上面说的”不加锁“，阳哥在这只说了使用lpop去抢红包，并没有解释数据一致性的实现，我的理解是在拆分红包的二分均值算法中的在最后一个包时分配”总金额-已抢金额“，这里就可以保证金额不超额，而在抢红包时只需要保证抢的包个数不大于分包总个数即可，这就和抢票系统一样了，在每次抢红包时判断剩余红包个数大于0即可。</p><h3 id="4-记录红包争抢数据的功能怎么实现？"><a href="#4-记录红包争抢数据的功能怎么实现？" class="headerlink" title="4.记录红包争抢数据的功能怎么实现？"></a><strong>4.记录红包争抢数据的功能怎么实现？</strong></h3><p>类似于微信红包，结束后会显示每个人抢了多少，这就需要记录短期的个人抢红包数据，阳哥还提了一点就是需要记录长期的数据，比如一年中发了多少红包和抢了多少红包，这一点有点类似于微信的账单功能，怎么去记录呢？首先数据结构选择Redis的Hash结构，在每一次请红包后，使用”hset 活动id 用户id 金额”存入每个用户抢了多少红包，年度红包统计就比较简单了，将每次抢发红包数分别加起来就可以了，至于数据的持久化，也可以将数据存入mySql中。</p><h3 id="5-发送的红包未抢完在24小时后回退给发送者怎么实现？"><a href="#5-发送的红包未抢完在24小时后回退给发送者怎么实现？" class="headerlink" title="5.发送的红包未抢完在24小时后回退给发送者怎么实现？"></a><strong>5.发送的红包未抢完在24小时后回退给发送者怎么实现？</strong></h3><p>这个功能就比较简单了，在活动结束后，计算剩余金额，设置定时任务，24小时后回退即可，可以使用redis实现也可以使用MQ实现。</p><p>这个功能和订单下单5分钟未付款就取消订单一个原理，后面有时间我也会去整理一下该功能的实现思路。</p><h2 id="并发量持续加大，怎么处理？（集群）"><a href="#并发量持续加大，怎么处理？（集群）" class="headerlink" title="并发量持续加大，怎么处理？（集群）"></a><strong>并发量持续加大，怎么处理？（集群）</strong></h2><p>上面单机模式作为一个微服务，在并发量持续加大的情况下就需要做集群处理了。</p><p>在集群中需要考虑的问题：<br>1.如果有人盗刷，怎么配置白名单？<br>2.怎么做到削峰限流、服务熔断、服务降级、服务流控，最终实现分割+限流+软件负载均衡？</p><p>实现这两个问题中的功能有很多种方法，问题一可以用gateway业务网关+隔离策略解决，问题二中的限流就可以用nginx流量网关解决，但是负载均衡就需要配置集群的负载均衡策略了。</p><h2 id="前后端调用架构？"><a href="#前后端调用架构？" class="headerlink" title="前后端调用架构？"></a><strong>前后端调用架构？</strong></h2><p>整体流程架构图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/image.png" alt=""></p><p>课程为了节省时间，前后端交互使用的是WebSocket，在正式搭建时，可以使用MQ，在活动开始前将所有发送请求的用户放入WebSocket候客室中，活动开始准时进行抢红包活动。</p><h2 id="更近一步的服务扩容？"><a href="#更近一步的服务扩容？" class="headerlink" title="更近一步的服务扩容？"></a><strong>更近一步的服务扩容？</strong></h2><p>这一步讲的就是在云上去部署组件集群、服务集群等，课程中是在阿里云服务器进行部署，个人认为这部分讲的最好，雷神一步一步操作教学，看的我挺上瘾的，收获也不少。</p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a><strong>小结：</strong></h2><p>尚硅谷的这四节直播课的含金量非常高，本文也相当于对第一节课程做了一篇笔记，现在再想想当时的那道面试题：如果要设计一个红包系统，比如春晚红包雨，在这种高并发的环境下，该怎么设计？我会先讲整体架构，然后讲怎么数据一致性+不加锁+高可用，后面再讲讲集群…唉，只能说相见恨晚啊！课程链接放下面，需要的友友可以直接点击跳转，也可以直接去B站搜索“红包雨开发架构设计”。</p><p>红包雨架构分析：<a href="https://www.bilibili.com/video/BV18k4y1P7sh/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=27972b4e93b4f51f10811f1f46f853b4">https://www.bilibili.com/video/BV18k4y1P7sh/?spm_id_from=333.1007.top_right_bar_window_history.content.click&amp;vd_source=27972b4e93b4f51f10811f1f46f853b4</a></p><p>中间件与交互设计：<a href="https://www.bilibili.com/video/BV18k4y1P7sh?p=2">https://www.bilibili.com/video/BV18k4y1P7sh?p=2</a></p><p>UI与前后端联调：<a href="https://www.bilibili.com/video/BV18k4y1P7sh?p=3&amp;vd_source=27972b4e93b4f51f10811f1f46f853b4">https://www.bilibili.com/video/BV18k4y1P7sh?p=3&amp;vd_source=27972b4e93b4f51f10811f1f46f853b4</a></p><p>云上弹性部署：<a href="https://www.bilibili.com/video/BV18k4y1P7sh?p=4&amp;vd_source=27972b4e93b4f51f10811f1f46f853b4">https://www.bilibili.com/video/BV18k4y1P7sh?p=4&amp;vd_source=27972b4e93b4f51f10811f1f46f853b4</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 红包雨系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对当下高等教育的一点思考</title>
      <link href="/2023/07/01/think-1/"/>
      <url>/2023/07/01/think-1/</url>
      
        <content type="html"><![CDATA[<p>其实很早就想写点这方面的东西了，但是想法很杂，也一直在考虑发出来合不合适，毕竟现在很多事扯上某些字就会有很多问题，但是最近的一些事让人忍不住想写，先手动狗头保个命吧，声明：本文仅代表个人观点，无引导意向，权当看乐。</p><p>今天看到网友们整活：由山东、山西、河南、河北四省联办山河大学，选址在四省交界处，校长为杜甫，意在“大庇天下寒士俱欢颜”，专业有两个，考公和考研，目标“三年超清华，五年赶北大”，效率也很高：上午出想法，中午出方案，下午出校徽，晚上出宿舍和四门规划设计，现在校园卡，录取通知书，校园表白墙等等，应有尽有。</p><p>说实话，内心居然还有点相信这学校可以做起来，当然更多的是看个热闹，不过这热闹背后也反应了一些问题：先提一下教育资源分配不合理的问题吧，河南省作为高考大省，居然没有一所985高校，连211高校都只有一所，更有“山河四省凑不出三所985”的评论刷屏，当然这里面的缘由很多，我也说不清，这也不是我思考的重点，只是有点心疼这四个省的学生。我更关注的点是山河大学只有两个专业：考研和考公，这个点再次激起了我对现在高等教育的思考。</p><p>首先，我个人觉得应该加一个“就业”专业，大多数大学生都会面临的一个重大抉择就是：未来是考公？考研？还是就业？站在现阶段自己的角度，一位双非本科准大四学生的角度，这三条路都是那么的难走。</p><p>为什么难走？以就业来说，学完了学校安排的各门课程，甚至成绩还都不错，但是简历照样没有东西可写，面试照样一问三不知。我很认同山河大学只有“考公和考研”两个专业，直接将教学目标定位到未来选择方向上，而不是打着“要培养出德智体美劳全面发展的优秀人才”旗号将学生们一把抓，按照几十年前的培养方案来开设课程，到大三学生做选择时，发现自己选就业吧，好像根本没学到什么技术；选考公吧，行测申论也要从头来学；也就考研课程全学过，但是也是为了期末考试学的，经过其他无关课程的学习，该忘的也忘的差不多了。</p><p>如果能从一开始就将培养计划定为：就业/考公/考研，用三年的时间去冲击现在一年时间的目标，是不是更容易？学生的压力是不是会小很多？甚至很多学生可以同时进行两手甚至三手打算，时间完全足够，这样不好吗？当然，如果真的这样推行了，也会有很多问题，首先，热门就业专业火爆，考研考公专业也一样，但是冷门专业面临这取消，很多教师会失业；其次，资本会继续提高对求职者的能力下限要求，行业更加内卷；还有考研考公率上升，考研考公人数继续增加，内卷更加严重…问题是很多，但是改革必定伴随着动荡，动荡最终会趋于稳定，还记得初中历史讲过，进步的两种方式：改革和革命，中国不是很擅长逐步推进嘛，我也很相信中国会有更好的方案，或者有能力解决这些问题，教育制度不能就这么停滞不前。</p><p>最近张雪峰的事也闹的沸沸扬扬，张雪峰在最该说话的时候“被迫住院”，甚至人民日报都轰击他，可见他动的蛋糕有多大，他给别人推荐专业都是根据家庭情况考虑，以就业为目的推荐的，这有什么错呢？所谓我们大学生处于最美好的年纪，我们不应该一味的去思考就业，我们目标高远，为理想奋斗，励志为祖国做奉献…编不下去了，这种所谓的高远理想是应该存在于小学生的心中的，现在社会对大学毕业生的剥削很严重，理想？理想能当饭吃吗？工作才有工资，有工资才能生活，这就是现实啊，大多数普通大学生毕业后都是需要就业的吧，甚至于考公考研不也是为了更好就业吗？所以我认为高等教育将就业为目标并没有错。</p><p>前不久有学生放假前提前请假导员没批然后擅自离校给处分的热搜，当然这件事，学生肯定有错，我也不打算重点说这件事，我看见很多评论是“学生不就应该上课吗？”“不去上课是对老师的不尊重”等等，其实这两句话没错，但是放在大学生身上不合适。<br>为什么很多大学生选择逃课？贪玩是一部分原因，但是也有很多其他因素，首先，我其实一直坚信在大学很多事情远比上课重要：“去见一见许久未见的朋友”，“去看一场唯美且治愈的日出”，“去奔赴一场爱情”…。</p><p>其次，老师们是不是也需要反思一下？课程质量低下，讲课没有丝毫激情，甚至有老师声音小到只有前三排能听清，这种课去上有什么意义呢？另外，现在网络资源丰富，很多老师的讲课水平远远跟不上B站老师的水平，而且上课两小时讲清的内容，B站老师二十分钟就能讲清，我为什么要在课堂上浪费时间呢？</p><p>说实话，有时候我觉得“平时分”这个东西的存在也并不合理，甚至有人期末考八十多，但因为平时分低而挂科，我也不知道这样的老师是什么心理？是为了保证自己教学的成绩保持正态分布？还是宣告自己的权威？我觉得如果说教学的目的是为了让学生掌握知识，那不管学生以什么方式掌握都应该被允许，而不是限制在教室，如果教学的目的是为了应试，那么既然期末考过了就不应该被挂科，有人会以最开始我提到的“”学生的职责就是上课”“不上课你尊重老师了吗？”来反驳我，那么请问，老师的职责不是积极备课，提高教学水平给学生教学吗？，某些老师拿着几年十几年前早已经过时的ppt照着读，他们尽了他们的职责了吗？他们尊重学生了吗？当然，也有很多优秀的教师，这样的课逃课人数肯定想较少，这都是相互的。</p><p>最后，还有一个原因就是上面提到的课程安排不合理。如果学校安排的课程，尤其是一些专业课讲的知识，与学生就业方向不沾边，以后根本用不到，虽然很对专业课是自己选择的，但是一些学校一些专业提供的可选课程本来就少，为了修够学分只能被迫选择，另外，当一门课程选择人数少时，这门课程压根就开不起来，所以选不到合适的课程的概率还是非常大的，这时再去强迫学生上这门课，是不是不合理？学生利用上课时间去学习一些就业相关知识是不是更有用？</p><p>其实归根到底是高等教育制度落后于时代的发展，个人认为这个问题是很严重的，是急需被重视的。</p><p>这篇文章改了又改，我尽量让自己的措辞恰当一些，“文字狱”被废除这么久了，很多话还是不能说，尤其是关于残酷事实的zhen话，张雪峰被迫闭嘴，这是时代的悲哀，也让人害怕，我也怕，所以再次声明，本文仅个人观点，无不良言论，无引导意向，理性看待，求放过。</p>]]></content>
      
      
      <categories>
          
          <category> 胡思乱想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等教育 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>南京，江南，心念</title>
      <link href="/2023/04/13/trip-1/"/>
      <url>/2023/04/13/trip-1/</url>
      
        <content type="html"><![CDATA[<p>在我心中，南京一直是一座浪漫的城市，不仅仅因为“宋庆龄一句喜欢梧桐，蒋介石就为她将梧桐种满南京”，更因为我的心心念念在南京。“总要去趟南京吧”，一直就有这个念头，却始终迈不出第一步，也因此错过了一些。终于舍友一句说走就走，让我下定决心去看看。</p><p>火车上，我发了一条朋友圈，是我去南京的车票，想着给她一个选择，也给了我一个机会，但凡她问一句，我都会不顾一切的去见一见她。硬座，睡不好，每隔十几分钟我就忍不住打开朋友圈，可惜，连她的点赞都没等到。我想安慰自己，却找不到合适的借口，思来想去，也只能接受：她深知自己的点赞评论意味着什么，她压根不想见我。回想着过往的种种，我在想，如果早点奔赴，是不是就不会失去？</p><p>终究是不甘心，我只安慰自己她没看见，到了南京，我发了一条微博作为最后的倔强。南京挺美的，只是等不到在等的，总会是有些遗憾。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/349426602.jpeg" alt="349426602"></p><p>好在美景可以治愈心灵，看着沿途的景色，也能感受到世界如此美好；好在运动可以给人多巴胺，走着走着似乎也就没有那么emo了。</p><p>有人劝我去见她一面，将想说的全都说出来，免得自己留遗憾，但是，我也早就决定，既然她不想见我，那我就不去打扰她了。我也能想明白，或许真的该放下了，这次回去之后该好好生活了。</p><p>鸡鸣寺的樱花过了，樱桃都冒出了绿头；天气不是太好，不时会下一阵小雨；梧桐也没有长出茂盛的绿叶，光秃秃的。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/2113595292.jpeg" alt="2113595292"></p><p>买到了十八籽；盖了好多章；看见了音乐台成片飞舞的白鸽；老门东的紫藤萝也很绚烂。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/2112668922.jpeg" alt="2112668922"></p><p>遗憾不遗憾的都该奔赴下一站了，据说江南很美且春不晚。嘴上轻松说着放下，却还是忍不住发了最后一条朋友圈“再见，我心心念念的”，我知道，她读得懂，所有人都读得懂。</p><p>坐上了去往苏州的列车，二等座居然是无座，价格居然一样，好在距离不远，索性站着过去，听听音乐，看看窗外的景色，也还不错。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/2119139180.jpeg" alt="2119139180"></p><p>距离下车还有两分钟，她问，几点的车？发来了一张南京站的照片，还是错过了。她说她也来苏州玩。我在山塘街的小店里留了一张纸条，我想缘分到这了，其余的也就交给命运吧，或许偶遇，或许继续错过，我都认。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/2142130236.jpeg" alt="2142130236"></p><p>苏州人很多，走在一起都可能被冲散，偶遇的话，会看见吗？她说，苏州旅途愉快，我说，你也一样。</p><p>距离返程还有6个小时，忽然很想见一面，可是啊没有身份，没有理由。我想起了手绘书签，送她一张手绘书签吧。从山塘街走到平江路再走到耦园，很可惜，四家店，除耦园那家我压根没找到外，其他几家连预约都满了。苏州的太阳很大，街上人很多，人心中很烦闷。</p><p>距离返程还有2小时，我想，问问她吧，于是问了一个自认为还算合适的问题，有没有好看的电视剧或者小说？还剩1小时，她还是没回消息。我觉得她不想理我。还剩40分钟，她回消息了，她说，她刚下火车，她和我说了挺多，我甚至看到了一点关心的意思。快检票了，结束了聊天。忽然释然了，原来一直小气的人，都是我自己，所有的一切一切都是我自己心魔作妖罢了，她从来没有那么在意，也从来没有那么不在意。她向我推荐了电视剧《长月烬明》。</p><p>坐上了返程的火车，看着《长月烬明》，说实话，不那么好看，但也不那么难看。从南京到苏州，或许缘分已经尽力了，可我还是那么懦弱，终究还是错过，不过好像也释怀了不少。南京和苏州的景色很美，像心念一样美。</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/-432098106.jpeg" alt="-432098106"></p>]]></content>
      
      
      <categories>
          
          <category> 旅游日记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 南京 </tag>
            
            <tag> 苏州 </tag>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟机中用Docker安装并启动了Elasticsearch，浏览器却访问不了</title>
      <link href="/2023/04/02/study-10/"/>
      <url>/2023/04/02/study-10/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注意：本文原发于CSDN：<a href="http://t.csdnimg.cn/MFvOn">http://t.csdnimg.cn/MFvOn</a> ,现已被杭州城市开发者社区收录，转载请标明出处。</p></blockquote><p>学习springCloud的过程及其痛苦，一直跟着黑马的视频走，但是随着技术栈的更新，许多技术的配置与黑马视频讲的会有出入，然后就会遇到一些很头疼的问题，有时候一个问题需要找很久的原因与解决方法，所以记录一下这些问题防忘吧(由于是尝试过程中解决了问题，没有截图，但说的还算详细)。</p><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><p>在学习到Elasticsearch时，我用docker安装并启动了Elasticsearch,前期过程挺顺利的，但是在用浏览器访问的时候出问题了，怎么也访问不到，提示拒绝访问。</p><h3 id="解决过程："><a href="#解决过程：" class="headerlink" title="解决过程："></a>解决过程：</h3><h4 id="1-防火墙问题："><a href="#1-防火墙问题：" class="headerlink" title="1. 防火墙问题："></a>1. 防火墙问题：</h4><p>网上大部分说的就是防火墙的问题，但是在刚学docker时，我就关闭了防火墙并且禁止了开机启动，给有需要的提供下命令吧：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state # 查看防火墙状态</span><br><span class="line">systemctl stop firewalld.service # 停止firewall</span><br><span class="line">systemctl disable firewalld.service # 禁止firewall开机启动</span><br><span class="line">reboot # 重启虚拟机</span><br></pre></td></tr></table></figure><h4 id="2-max-map-count太小："><a href="#2-max-map-count太小：" class="headerlink" title="2. max_map_count太小："></a>2. max_map_count太小：</h4><p>第二种比较多的说法是：max_map_count太小了，但是我修改了之后问题依然没有解决，命令如下：</p><p>先查看max_map_count值（一般是65530，但如果是262144就不用改）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/vm/max_map_count</span><br><span class="line">65530</span><br></pre></td></tr></table></figure><p>修改65530为262144:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">临时修改</span></span><br><span class="line">sysctl -w vm.max_map_count=262144</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">永久修改</span></span><br><span class="line">vm.max_map_count=262144​</span><br></pre></td></tr></table></figure><h4 id="3-虚拟机内存不足以给ES分配："><a href="#3-虚拟机内存不足以给ES分配：" class="headerlink" title="3. 虚拟机内存不足以给ES分配："></a>3. 虚拟机内存不足以给ES分配：</h4><p>还有说法是ES占用的内存比较多，如果虚拟机内存不足以分配给ES时会导致启动失败，解决方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看ES的容器<span class="built_in">id</span>：</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除ES容器：</span></span><br><span class="line">docker rm + 容器id</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">新建ES容器（重点加上-e <span class="string">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span>）：</span></span><br><span class="line">docker run -d \</span><br><span class="line">--name es \</span><br><span class="line">-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \</span><br><span class="line">-e &quot;discovery.type=single-node&quot; \</span><br><span class="line">-v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-v /path/to/data/dir:/usr/share/elasticsearch/data \</span><br><span class="line">--network es-net \</span><br><span class="line">--privileged \</span><br><span class="line">-p 9200:9200 \</span><br><span class="line">-p 9300:9300 \</span><br><span class="line">elasticsearch:7.12.1</span><br></pre></td></tr></table></figure><p>这个是黑马视频中说到过的，所以我也是加上的，对我的问题没有帮助。</p><h3 id="正解：挂载点目录问题："><a href="#正解：挂载点目录问题：" class="headerlink" title="正解：挂载点目录问题："></a>正解：挂载点目录问题：</h3><h4 id="1-查看日志："><a href="#1-查看日志：" class="headerlink" title="1. 查看日志："></a>1. 查看日志：</h4><p>我在寻求方法时，偶然发现，这个命令可以查看Elasticsearch的日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看最新日志（默认情况下使用-f选项）</span></span><br><span class="line">docker logs -f +容器id或者镜像名</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看特定时间段内的日志：</span></span><br><span class="line">docker logs --since 2022-01-01 +容器id或者镜像名</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅查看错误日志：</span></span><br><span class="line">docker logs --since 1d --grep ERROR +容器id或者镜像名</span><br></pre></td></tr></table></figure><p>然后我查看了我的日志，发现在我浏览器访问ip:9200时，会出现这个错误并且此时我的容器会被自动删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ElasticsearchException[failed to bind service]; nested: FileSystemException[/usr/share/elasticsearch/data/nodes/0: Not a directory];</span><br><span class="line">Likely root cause: java.nio.file.FileSystemException: /usr/share/elasticsearch/data/nodes/0: Not a directory</span><br></pre></td></tr></table></figure><h4 id="2-尝试修复："><a href="#2-尝试修复：" class="headerlink" title="2. 尝试修复："></a>2. 尝试修复：</h4><p>大致意思就是说我的挂载目录不存在，但是我单独创建了目录后，还是会报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uncaught exception in thread [main]</span><br><span class="line">ElasticsearchException[failed to bind service]; nested: AccessDeniedException[/usr/share/elasticsearch/data/nodes];</span><br><span class="line">Likely root cause: java.nio.file.AccessDeniedException: /usr/share/elasticsearch/data/nodes</span><br></pre></td></tr></table></figure><p>然后我就针对目录做了一系列的我能想到的方法，但是都没解决问题。</p><h4 id="3-正确方法："><a href="#3-正确方法：" class="headerlink" title="3. 正确方法："></a>3. 正确方法：</h4><p>无奈之下，我只能完全删除了Elasticsearch的镜像以及容器，重新安装，但是在安装之前先创建挂载点文件目录！</p><p>下面为docker安装lasticsearch的完整步骤：</p><p>(1) 创建一个网络，方便后期部署kibana:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create es-net</span><br></pre></td></tr></table></figure><p>(2) docker拉取Elasticsearch，不知道为什么在拉取Elasticsearch时，必须加tag，不能直接用latest:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">必须选取一个tag,以7.12.1为例：</span></span><br><span class="line">docker pull elasticsearch:7.12.1</span><br></pre></td></tr></table></figure><p>(3) 创建搭载目录（重点！！！很多教程都没有）:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /mydata/elasticsearch/config</span><br><span class="line">mkdir -p /mydata/elasticsearch/data</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将http.host: 0.0.0.0写入到es配置文件中，代表能被远程的任何机器访问：</span></span><br><span class="line">echo &quot;http.host: 0.0.0.0&quot; &gt; /mydata/elasticsearch/config/elasticsearch.yml</span><br></pre></td></tr></table></figure><p>(4) 创建容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name es \</span><br><span class="line">-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \</span><br><span class="line">-e &quot;discovery.type=single-node&quot; \</span><br><span class="line">-v es-plugins:/usr/share/elasticsearch/plugins \</span><br><span class="line">-v /path/to/data/dir:/usr/share/elasticsearch/data \</span><br><span class="line">--network es-net \</span><br><span class="line">--privileged \</span><br><span class="line">-p 9200:9200 \</span><br><span class="line">-p 9300:9300 \</span><br><span class="line">elasticsearch:7.12.1</span><br></pre></td></tr></table></figure><blockquote><p>解释：</p><p>-e “cluster.name=es-docker-cluster”：设置集群名称</p><p>-e “http.host=0.0.0.0”：监听的地址，可以外网访问</p><p>-e “ES_JAVA_OPTS=-Xms512m -Xmx512m”：内存大小</p><p>-e “discovery.type=single-node”：非集群模式</p><p>-v es-data:/usr/share/elasticsearch/data：挂载逻辑卷，绑定es的数据目录</p><p>-v es-plugins:/usr/share/elasticsearch/plugins：挂载逻辑卷，绑定es的插件目录</p><p>—privileged：授予逻辑卷访问权</p><p>—network es-net ：加入一个名为es-net的网络中</p><p>-p 9200:9200：端口映射配置</p></blockquote><p>(5) 浏览器访问：虚拟机ip:9200,出现以下页面代表访问成功(edge浏览器出现的为json格式)：</p><p><img src="https://cdn.jsdelivr.net/gh/twigIcer/markdown-img@main/imgs/d87df99b92e74d908a33565c08b0228a.png" alt=""></p><p> 问题解决！！！</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>这次的问题主要是，事前没有准备挂载点目录，其实黑马的视频和很多教程也没有这一步，所以绕了很大的弯子，花费很长时间的另一个原因是：我没有及时的查看日志，其实程序员遇到错误时第一项该做的就是查看日志，而我首先是去盲目的搜索答案了，也算让我长长记性吧。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java字符串遍历时，toCharArray()方法与charAt()方法效率比较</title>
      <link href="/2023/03/26/study-10/"/>
      <url>/2023/03/26/study-10/</url>
      
        <content type="html"><![CDATA[<h2 id="问题提出："><a href="#问题提出：" class="headerlink" title="问题提出："></a>问题提出：</h2><p>最近在力扣刷题时，发现在字符串遍历时，大佬们通常会使用 toCharArray () 方法，而很少使用 harAt () 方法，于是我就挺好奇这两种方法到底谁的效率会高一点呢？我就去跑了一些测试案例，但是结果却是时不时 toCharArray () 效率高，时不时是 charAt () 效率高，我觉得可能是我的测试案例的字符串长度不够，但是我字符串长度加到我认为足够长时，我发现 charAt () 的效率明显高于 toCharArray ()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;这里面的字符串内容就省略了，知道它足够长就可以&quot;</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="type">long</span> <span class="variable">st1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : ch) &#123;</span><br><span class="line">            System.out.print(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">et1</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">rt1</span> <span class="operator">=</span> et1 - st1;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(rt1);</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------------------------------&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="type">long</span> <span class="variable">st2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            System.out.print(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">et2</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">rt2</span> <span class="operator">=</span> et2 - st2;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(rt2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"><img src="https://img-blog.csdnimg.cn/df5adb0187f54eaa8d42d45aab7cb722.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>注意：我有多次测试，结果就是 toCharAray () 方法 30ms 左右，charAt () 方法 15ms 左右。</p><p>我就挺好奇，既然 charAt () 方法效率高，那为什么用 toCharArray () 方法的人多呢？难道是 charAt () 方法有什么弊端吗？</p><h2 id="探究过程："><a href="#探究过程：" class="headerlink" title="探究过程："></a>探究过程：</h2><p>于是我就询问了黑马的满老师，而满老师给我的回答是：” 我觉得没啥弊端吧，java api 层面的效率问题在我看来不是太重要 “。其实这个回答并不能完全解答我的疑惑，既然没有什么弊端，效率还高，那么在力扣着这种看重效率的平台，为什么很少使用 charAt () 方法呢？</p><p>然后我去网上搜了这个问题，但是回答能各执一词，没能很好的说服我，但是我发现很多人认为是 toCharArray () 方法效率高，但是这和我测试结果相悖啊。</p><p>然后我去 CSDN 发布了问答，可惜等来的只有一个回答，那就是：明显 toCharArray () 方法效率高，因为直接访问数组，但是 toCharArray () 本身是需要时间和额外内存的。这个回答怎么说呢，不太能让我信服。</p><p>碰巧在我复习 String 相关知识时，看见黑马的视频中说：使用 toCharArray () 方法效率会高，因为在使用 charAt () 方法遍历时会调用其他一些方法，这些方法入栈出栈会花时间。确实这个说法有道理，可是为什么和我测试结果不一致呢？</p><h2 id="应该是正解："><a href="#应该是正解：" class="headerlink" title="应该是正解："></a>应该是正解：</h2><p>最后我想到了 chatGPT，事实也证明，chatGPT 确实给力，至少它的回答让我信服了，它的回答如下：</p><blockquote><p>” 在 Java 中，字符串的 <code>charAt()</code> 方法和 <code>toCharArray()</code> 方法都可以用于遍历字符串，但它们的效率取决于具体的使用情况。</p><p>如果只需要遍历字符串中的单个字符，使用 <code>charAt()</code> 方法更为简便，因为它只需要访问字符串中的一个字符，因此在这种情况下，<code>charAt()</code> 方法的效率更高。</p><p>然而，如果需要遍历整个字符串并进行一些操作，例如将字符串转换为字符数组以进行某些处理，则使用 <code>toCharArray()</code> 方法可能更为高效。这是因为 <code>toCharArray()</code> 方法可以一次将整个字符串转换为字符数组，使得我们可以在数组上进行一系列的操作，比如修改、排序等等。而使用 <code>charAt()</code> 方法则需要反复访问字符串，效率较低。</p><p>综合来说，如果只需要遍历单个字符，使用 <code>charAt()</code> 方法更为高效，而如果需要对整个字符串进行操作，则使用 <code>toCharArray()</code> 方法可能更为高效。但在实际应用中，对于小型字符串，两种方法的差异并不明显，因此选择哪种方法取决于具体的情况和个人偏好。“</p></blockquote><p>不得不说它的回答很中肯，也符合我的测试案例，至于力扣用 <code>toCharArray()</code> 方法，也确实是他们并不是简单的遍历字符串，还有其他的操作。所以在我心里这个回答应该是正解。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>关于 Java 字符串遍历时，toCharArray () 方法与 charAt () 方法效率比较，我比较支持的观点为：</p><p>如果只需要遍历单个字符，使用 <code>charAt()</code> 方法更为高效，而如果需要对整个字符串进行操作，则使用 <code>toCharArray()</code> 方法可能更为高效。</p><p>但是对于小型字符串，两种方法的差异并不明显，也许正如满老师所说的：java api 层面的效率问题不是太重要吧。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 字符串遍历 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
